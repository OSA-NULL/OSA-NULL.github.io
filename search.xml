<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>每周咨询板块说明</title>
    <url>/2020/07/29/news/News0/</url>
    <content><![CDATA[<h1 id="每周咨询"><a href="#每周咨询" class="headerlink" title="每周咨询"></a>每周咨询</h1><p>我们每周收集有关开源界的新鲜事，重大事。并在周六准时更新。</p>
]]></content>
      <categories>
        <category>News</category>
      </categories>
  </entry>
  <entry>
    <title>Linux003 Linux文件系统</title>
    <url>/2019/11/15/tutorials/Linux/Linux003/</url>
    <content><![CDATA[<h1 id="Linux003-Linux文件系统"><a href="#Linux003-Linux文件系统" class="headerlink" title="Linux003 Linux文件系统"></a>Linux003 Linux文件系统</h1><blockquote>
<p>上一节，我们简单学习了Bash以及一些常用的命令，如<code>ls``cd``man</code>等，我们也会怎样看一个目录下的文件。最后的时候，我们补充了一些Linux文件系统的知识，现在我们就正式地介绍Linux的文件系统吧。我们通常知道什么是电脑硬盘，什么是分区，还常有人提醒我们不要把c盘塞得满满的，以及把游戏都安装在d盘等等…而在Linux系统中，和windows有些不同的是，他使用的是一种叫做 <strong>树结构</strong> 的structure来存储管理我们所有的文件。  </p>
</blockquote>
<p>这一节，你将学习到</p>
<ul>
<li>Linux的某些非常重要的目录，以及这些目录的用处（理论）</li>
<li>什么是配置文件（configuration file 或简称 config）（理论）</li>
<li>Linux下的用户权限（理论）</li>
<li>一些常用的文件操作命令（实践）</li>
</ul>
<p>学会了这一节，你就可以:</p>
<ul>
<li>从 删库 到 跑路（误），文件的 <code>预览</code>、<code>复制</code> <code>粘贴</code>（实际上这两在Linux只用一个命令<code>cp</code>）、<code>移动</code>、<code>删除</code>、<code>查找</code>。</li>
<li>用root用户轻易地搞崩自己的Linux系统，然后愉快地重装</li>
<li>自己配置一个超级好看（巨丑无比）的桌面环境 和 terminal 配色</li>
<li>学会用一个上古神器（grep）</li>
</ul>
<blockquote>
<p>PS：这一节的内容会有点多，大家慢慢看慢慢学，要注重理论结合实践，不要怕把系统给弄崩了。  </p>
</blockquote>
<p>好的，下面进入正题</p>
<a id="more"></a>

<h2 id="什么是文件系统"><a href="#什么是文件系统" class="headerlink" title="什么是文件系统"></a>什么是文件系统</h2><p><strong>文件系统</strong>是操作系统用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的方法和数据结构；即在存储设备上组织文件的方法。<br>上面那句话已经说得很清楚了</p>
<p><strong><em>文件系统是</em></strong> <del>(用于明确存储设备（常见的是磁盘，也有基于NAND Flash的固态硬盘）或分区上的文件的)</del> <strong><em>方法</em></strong> 和 <strong><em>数据结构</em></strong>；即 <strong><em>在存储设备上组织文件的方法</em></strong>。</p>
<p>在Linux上我们看到的文件大概是这样的：</p>
<p>这里我先搬运一张上一节的那个Linux结构图：<br><img src="file_system.png" alt="Linux file system"></p>
<p>你可能不记得这张图了，但他却是你以后经常要见的，你会经常<code>cd</code>进去，比如<code>cd /etc</code> <code>cd /usr</code>，或者做一些修改，比如用<code>vim</code> or <code>cp</code> 到个人目录下。总之他很重要。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>03 - 分支结构</title>
    <url>/2019/10/02/tutorials/Python/03.%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="03-分支结构"><a href="#03-分支结构" class="headerlink" title="03 - 分支结构"></a>03 - 分支结构</h2><h3 id="分支结构的应用场景"><a href="#分支结构的应用场景" class="headerlink" title="分支结构的应用场景"></a>分支结构的应用场景</h3><p>迄今为止，我们写的Python代码都是一条一条语句顺序执行，这种结构的代码我们称之为顺序结构。然而仅有顺序结构并不能解决所有的问题，比如我们设计一个游戏，游戏第一关的通关条件是玩家获得1000分，那么在完成本局游戏后我们要根据玩家得到分数来决定究竟是进入第二关还是告诉玩家“Game Over”，这里就会产生两个分支，而且这两个分支只有一个会被执行，这就是程序中分支结构。类似的场景还有很多，给大家一分钟的时间，你应该可以想到至少5个以上这样的例子，赶紧试一试。</p>
<h3 id="if语句的使用"><a href="#if语句的使用" class="headerlink" title="if语句的使用"></a>if语句的使用</h3><p>在Python中，要构造分支结构可以使用<code>if</code>、<code>elif</code>和<code>else</code>关键字。所谓关键字就是有特殊含义的单词，像<code>if</code>和<code>else</code>就是专门用于构造分支结构的关键字，很显然你不能够使用它作为变量名（事实上，用作其他的标识符也是不可以）。下面的例子中演示了如何构造一个分支结构。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用户身份验证</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">username = input(<span class="string">'请输入用户名: '</span>)</span><br><span class="line">password = input(<span class="string">'请输入口令: '</span>)</span><br><span class="line"><span class="comment"># 如果希望输入口令时 终端中没有回显 可以使用getpass模块的getpass函数</span></span><br><span class="line"><span class="comment"># import getpass</span></span><br><span class="line"><span class="comment"># password = getpass.getpass('请输入口令: ')</span></span><br><span class="line"><span class="keyword">if</span> username == <span class="string">'admin'</span> <span class="keyword">and</span> password == <span class="string">'123456'</span>:</span><br><span class="line">    print(<span class="string">'身份验证成功!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'身份验证失败!'</span>)</span><br></pre></td></tr></table></figure>

<p>唯一需要说明的是和C/C++、Java等语言不同，Python中没有用花括号来构造代码块而是使用了缩进的方式来设置代码的层次结构，如果<code>if</code>条件成立的情况下需要执行多条语句，只要保持多条语句具有相同的缩进就可以了，换句话说连续的代码如果又保持了相同的缩进那么它们属于同一个代码块，相当于是一个执行的整体。</p>
<p>当然如果要构造出更多的分支，可以使用<code>if…elif…else…</code>结构，例如下面的分段函数求值。</p>
<p>$$f(x)=\begin{cases} 3x-5&amp;\text{(x&gt;1)}\x+2&amp;\text{(-1}\leq\text{x}\leq\text{1)}\5x+3&amp;\text {(x&lt;-1)}\end{cases}$$</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">分段函数求值</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        3x - 5  (x &gt; 1)</span></span><br><span class="line"><span class="string">f(x) =  x + 2   (-1 &lt;= x &lt;= 1)</span></span><br><span class="line"><span class="string">        5x + 3  (x &lt; -1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">x = float(input(<span class="string">'x = '</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">    y = <span class="number">3</span> * x - <span class="number">5</span></span><br><span class="line"><span class="keyword">elif</span> x &gt;= <span class="number">-1</span>:</span><br><span class="line">    y = x + <span class="number">2</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = <span class="number">5</span> * x + <span class="number">3</span></span><br><span class="line">print(<span class="string">'f(%.2f) = %.2f'</span> % (x, y))</span><br></pre></td></tr></table></figure>

<p>当然根据实际开发的需要，分支结构是可以嵌套的，例如判断是否通关以后还要根据你获得的宝物或者道具的数量对你的表现给出等级（比如点亮两颗或三颗星星），那么我们就需要在<code>if</code>的内部构造出一个新的分支结构，同理<code>elif</code>和<code>else</code>中也可以再构造新的分支，我们称之为嵌套的分支结构，也就是说上面的代码也可以写成下面的样子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">分段函数求值</span></span><br><span class="line"><span class="string">		3x - 5	(x &gt; 1)</span></span><br><span class="line"><span class="string">f(x) =	x + 2	(-1 &lt;= x &lt;= 1)</span></span><br><span class="line"><span class="string">		5x + 3	(x &lt; -1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">x = float(input(<span class="string">'x = '</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; <span class="number">1</span>:</span><br><span class="line">    y = <span class="number">3</span> * x - <span class="number">5</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">-1</span>:</span><br><span class="line">        y = x + <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        y = <span class="number">5</span> * x + <span class="number">3</span></span><br><span class="line">print(<span class="string">'f(%.2f) = %.2f'</span> % (x, y))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong>大家可以自己感受一下这两种写法到底是哪一种更好。在之前我们提到的Python之禅中有这么一句话“Flat is better than nested.”，之所以提出这个观点是因为嵌套结构的嵌套层次多了之后会严重的影响代码的可读性，如果可以使用扁平化的结构就不要去用嵌套，因此之前的写法是更好的做法。</p>
</blockquote>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：英制单位与公制单位互换"><a href="#练习1：英制单位与公制单位互换" class="headerlink" title="练习1：英制单位与公制单位互换"></a>练习1：英制单位与公制单位互换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">英制单位英寸和公制单位厘米互换</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">value = float(input(<span class="string">'请输入长度: '</span>))</span><br><span class="line">unit = input(<span class="string">'请输入单位: '</span>)</span><br><span class="line"><span class="keyword">if</span> unit == <span class="string">'in'</span> <span class="keyword">or</span> unit == <span class="string">'英寸'</span>:</span><br><span class="line">    print(<span class="string">'%f英寸 = %f厘米'</span> % (value, value * <span class="number">2.54</span>))</span><br><span class="line"><span class="keyword">elif</span> unit == <span class="string">'cm'</span> <span class="keyword">or</span> unit == <span class="string">'厘米'</span>:</span><br><span class="line">    print(<span class="string">'%f厘米 = %f英寸'</span> % (value, value / <span class="number">2.54</span>))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'请输入有效的单位'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="练习2：掷骰子决定做什么"><a href="#练习2：掷骰子决定做什么" class="headerlink" title="练习2：掷骰子决定做什么"></a>练习2：掷骰子决定做什么</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">掷骰子决定做什么事情</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">face = randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line"><span class="keyword">if</span> face == <span class="number">1</span>:</span><br><span class="line">    result = <span class="string">'唱首歌'</span></span><br><span class="line"><span class="keyword">elif</span> face == <span class="number">2</span>:</span><br><span class="line">    result = <span class="string">'跳个舞'</span></span><br><span class="line"><span class="keyword">elif</span> face == <span class="number">3</span>:</span><br><span class="line">    result = <span class="string">'学狗叫'</span></span><br><span class="line"><span class="keyword">elif</span> face == <span class="number">4</span>:</span><br><span class="line">    result = <span class="string">'做俯卧撑'</span></span><br><span class="line"><span class="keyword">elif</span> face == <span class="number">5</span>:</span><br><span class="line">    result = <span class="string">'念绕口令'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = <span class="string">'讲冷笑话'</span></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>上面的代码中使用了random模块的randint函数生成指定范围的随机数来模拟掷骰子。</p>
</blockquote>
<h4 id="练习3：百分制成绩转等级制"><a href="#练习3：百分制成绩转等级制" class="headerlink" title="练习3：百分制成绩转等级制"></a>练习3：百分制成绩转等级制</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">百分制成绩转等级制成绩</span></span><br><span class="line"><span class="string">90分以上    --&gt; A</span></span><br><span class="line"><span class="string">80分~89分    --&gt; B</span></span><br><span class="line"><span class="string">70分~79分	   --&gt; C</span></span><br><span class="line"><span class="string">60分~69分    --&gt; D</span></span><br><span class="line"><span class="string">60分以下    --&gt; E</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">score = float(input(<span class="string">'请输入成绩: '</span>))</span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    grade = <span class="string">'A'</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    grade = <span class="string">'B'</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">    grade = <span class="string">'C'</span></span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    grade = <span class="string">'D'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    grade = <span class="string">'E'</span></span><br><span class="line">print(<span class="string">'对应的等级是:'</span>, grade)</span><br></pre></td></tr></table></figure>
<h4 id="练习4：输入三条边长如果能构成三角形就计算周长和面积"><a href="#练习4：输入三条边长如果能构成三角形就计算周长和面积" class="headerlink" title="练习4：输入三条边长如果能构成三角形就计算周长和面积"></a>练习4：输入三条边长如果能构成三角形就计算周长和面积</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">判断输入的边长能否构成三角形</span></span><br><span class="line"><span class="string">如果能则计算出三角形的周长和面积</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">a = float(input(<span class="string">'a = '</span>))</span><br><span class="line">b = float(input(<span class="string">'b = '</span>))</span><br><span class="line">c = float(input(<span class="string">'c = '</span>))</span><br><span class="line"><span class="keyword">if</span> a + b &gt; c <span class="keyword">and</span> a + c &gt; b <span class="keyword">and</span> b + c &gt; a:</span><br><span class="line">    print(<span class="string">'周长: %f'</span> % (a + b + c))</span><br><span class="line">    p = (a + b + c) / <span class="number">2</span></span><br><span class="line">    area = math.sqrt(p * (p - a) * (p - b) * (p - c))</span><br><span class="line">    print(<span class="string">'面积: %f'</span> % (area))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'不能构成三角形'</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>上面的代码中使用了<code>math</code>模块的<code>sqrt</code>函数来计算平方根。用边长计算三角形面积的公式叫做<a href="https://zh.wikipedia.org/zh-hans/海伦公式" target="_blank" rel="noopener">海伦公式</a>。</p>
</blockquote>
<h4 id="练习5：个人所得税计算器。"><a href="#练习5：个人所得税计算器。" class="headerlink" title="练习5：个人所得税计算器。"></a>练习5：个人所得税计算器。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入月收入和五险一金计算个人所得税</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">salary = float(input(<span class="string">'本月收入: '</span>))</span><br><span class="line">insurance = float(input(<span class="string">'五险一金: '</span>))</span><br><span class="line">diff = salary - insurance - <span class="number">3500</span></span><br><span class="line"><span class="keyword">if</span> diff &lt;= <span class="number">0</span>:</span><br><span class="line">    rate = <span class="number">0</span></span><br><span class="line">    deduction = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">1500</span>:</span><br><span class="line">    rate = <span class="number">0.03</span></span><br><span class="line">    deduction = <span class="number">0</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">4500</span>:</span><br><span class="line">    rate = <span class="number">0.1</span></span><br><span class="line">    deduction = <span class="number">105</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">9000</span>:</span><br><span class="line">    rate = <span class="number">0.2</span></span><br><span class="line">    deduction = <span class="number">555</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">35000</span>:</span><br><span class="line">    rate = <span class="number">0.25</span></span><br><span class="line">    deduction = <span class="number">1005</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">55000</span>:</span><br><span class="line">    rate = <span class="number">0.3</span></span><br><span class="line">    deduction = <span class="number">2755</span></span><br><span class="line"><span class="keyword">elif</span> diff &lt; <span class="number">80000</span>:</span><br><span class="line">    rate = <span class="number">0.35</span></span><br><span class="line">    deduction = <span class="number">5505</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    rate = <span class="number">0.45</span></span><br><span class="line">    deduction = <span class="number">13505</span></span><br><span class="line">tax = abs(diff * rate - deduction)</span><br><span class="line">print(<span class="string">'个人所得税: ￥%.2f元'</span> % tax)</span><br><span class="line">print(<span class="string">'实际到手收入: ￥%.2f元'</span> % (diff + <span class="number">3500</span> - tax))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>说明：</strong>上面的代码中使用了Python内置的<code>abs()</code>函数取绝对值来处理<code>-0</code>的问题。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>04 - 循环结构</title>
    <url>/2019/10/02/tutorials/Python/04.%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="04-循环结构"><a href="#04-循环结构" class="headerlink" title="04 - 循环结构"></a>04 - 循环结构</h2><h3 id="循环结构的应用场景"><a href="#循环结构的应用场景" class="headerlink" title="循环结构的应用场景"></a>循环结构的应用场景</h3><p>如果在程序中我们需要重复的执行某条或某些指令，例如用程序控制机器人踢足球，如果机器人持球而且还没有进入射门范围，那么我们就要一直发出让机器人向球门方向奔跑的指令。当然你可能已经注意到了，刚才的描述中其实不仅仅有需要重复的动作，还有我们上一个章节讲到的分支结构。再举一个简单的例子，比如在我们的程序中要实现每隔1秒中在屏幕上打印一个&quot;hello, world&quot;这样的字符串并持续一个小时，我们肯定不能够将<code>print(&#39;hello, world&#39;)</code>这句代码写上3600遍，如果真的需要这样做那么编程的工作就太无聊了。因此，我们需要了解一下循环结构，有了循环结构我们就可以轻松的控制某件事或者某些事重复、重复、再重复的发生。在Python中构造循环结构有两种做法，一种是<code>for-in</code>循环，一种是<code>while</code>循环。</p>
<h3 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h3><p>如果明确的知道循环执行的次数或者是要对一个容器进行迭代（后面会讲到），那么我们推荐使用<code>for-in</code>循环，例如下面代码中计算$\sum_{n=1}^{100}n$。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用for循环实现1~100求和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">101</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>需要说明的是上面代码中的<code>range</code>类型，<code>range</code>可以用来产生一个不变的数值序列，而且这个序列通常都是用在循环中的，例如：</p>
<ul>
<li><code>range(101)</code>可以产生一个0到100的整数序列。</li>
<li><code>range(1, 100)</code>可以产生一个1到99的整数序列。</li>
<li><code>range(1, 100, 2)</code>可以产生一个1到99的奇数序列，其中的2是步长，即数值序列的增量。</li>
</ul>
<p>知道了这一点，我们可以用下面的代码来实现1~100之间的偶数求和。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用for循环实现1~100之间的偶数求和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">101</span>, <span class="number">2</span>):</span><br><span class="line">    sum += x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>也可以通过在循环中使用分支结构的方式来实现相同的功能，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">用for循环实现1~100之间的偶数求和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">101</span>):</span><br><span class="line">    <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        sum += x</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>如果要构造不知道具体循环次数的循环结构，我们推荐使用<code>while</code>循环，<code>while</code>循环通过一个能够产生或转换出<code>bool</code>值的表达式来控制循环，表达式的值为<code>True</code>循环继续，表达式的值为<code>False</code>循环结束。下面我们通过一个“猜数字”的小游戏（计算机出一个1~100之间的随机数，人输入自己猜的数字，计算机给出对应的提示信息，直到人猜出计算机出的数字）来看看如何使用<code>while</code>循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">猜数字游戏</span></span><br><span class="line"><span class="string">计算机出一个1~100之间的随机数由人来猜</span></span><br><span class="line"><span class="string">计算机根据人猜的数字分别给出提示大一点/小一点/猜对了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">answer = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">    number = int(input(<span class="string">'请输入: '</span>))</span><br><span class="line">    <span class="keyword">if</span> number &lt; answer:</span><br><span class="line">        print(<span class="string">'大一点'</span>)</span><br><span class="line">    <span class="keyword">elif</span> number &gt; answer:</span><br><span class="line">        print(<span class="string">'小一点'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'恭喜你猜对了!'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(<span class="string">'你总共猜了%d次'</span> % counter)</span><br><span class="line"><span class="keyword">if</span> counter &gt; <span class="number">7</span>:</span><br><span class="line">    print(<span class="string">'你的智商余额明显不足'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong>上面的代码中使用了<code>break</code>关键字来提前终止循环，需要注意的是<code>break</code>只能终止它所在的那个循环，这一点在使用嵌套的循环结构（下面会讲到）需要引起注意。除了<code>break</code>之外，还有另一个关键字是<code>continue</code>，它可以用来放弃本次循环后续的代码直接让循环进入下一轮。</p>
</blockquote>
<p>和分支结构一样，循环结构也是可以嵌套的，也就是说在循环中还可以构造循环结构。下面的例子演示了如何通过嵌套的循环来输出一个九九乘法表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输出乘法口诀表(九九表)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'%d*%d=%d'</span> % (i, j, i * j), end=<span class="string">'\t'</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：输入一个数判断是不是素数。"><a href="#练习1：输入一个数判断是不是素数。" class="headerlink" title="练习1：输入一个数判断是不是素数。"></a>练习1：输入一个数判断是不是素数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入一个正整数判断它是不是素数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">Date: 2018-03-01</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">num = int(input(<span class="string">'请输入一个正整数: '</span>))</span><br><span class="line">end = int(sqrt(num))</span><br><span class="line">is_prime = <span class="literal">True</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, end + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> num % x == <span class="number">0</span>:</span><br><span class="line">        is_prime = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> is_prime <span class="keyword">and</span> num != <span class="number">1</span>:</span><br><span class="line">    print(<span class="string">'%d是素数'</span> % num)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'%d不是素数'</span> % num)</span><br></pre></td></tr></table></figure>

<h4 id="练习2：输入两个正整数，计算最大公约数和最小公倍数。"><a href="#练习2：输入两个正整数，计算最大公约数和最小公倍数。" class="headerlink" title="练习2：输入两个正整数，计算最大公约数和最小公倍数。"></a>练习2：输入两个正整数，计算最大公约数和最小公倍数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入两个正整数计算最大公约数和最小公倍数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">Date: 2018-03-01</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">x = int(input(<span class="string">'x = '</span>))</span><br><span class="line">y = int(input(<span class="string">'y = '</span>))</span><br><span class="line"><span class="keyword">if</span> x &gt; y:</span><br><span class="line">    x, y = y, x</span><br><span class="line"><span class="keyword">for</span> factor <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">    <span class="keyword">if</span> x % factor == <span class="number">0</span> <span class="keyword">and</span> y % factor == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'%d和%d的最大公约数是%d'</span> % (x, y, factor))</span><br><span class="line">        print(<span class="string">'%d和%d的最小公倍数是%d'</span> % (x, y, x * y // factor))</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h4 id="练习3：打印三角形图案。"><a href="#练习3：打印三角形图案。" class="headerlink" title="练习3：打印三角形图案。"></a>练习3：打印三角形图案。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">打印各种三角形图案</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">*</span></span><br><span class="line"><span class="string">**</span></span><br><span class="line"><span class="string">***</span></span><br><span class="line"><span class="string">****</span></span><br><span class="line"><span class="string">*****</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    *</span></span><br><span class="line"><span class="string">   **</span></span><br><span class="line"><span class="string">  ***</span></span><br><span class="line"><span class="string"> ****</span></span><br><span class="line"><span class="string">*****</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    *</span></span><br><span class="line"><span class="string">   ***</span></span><br><span class="line"><span class="string">  *****</span></span><br><span class="line"><span class="string"> *******</span></span><br><span class="line"><span class="string">*********</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">row = int(input(<span class="string">'请输入行数: '</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'*'</span>, end=<span class="string">''</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(row):</span><br><span class="line">        <span class="keyword">if</span> j &lt; row - i - <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">' '</span>, end=<span class="string">''</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'*'</span>, end=<span class="string">''</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(row):</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(row - i - <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">' '</span>, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2</span> * i + <span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'*'</span>, end=<span class="string">''</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>05- 构造程序逻辑</title>
    <url>/2019/10/02/tutorials/Python/05.%E6%9E%84%E9%80%A0%E7%A8%8B%E5%BA%8F%E9%80%BB%E8%BE%91/</url>
    <content><![CDATA[<h2 id="05-构造程序逻辑"><a href="#05-构造程序逻辑" class="headerlink" title="05- 构造程序逻辑"></a>05- 构造程序逻辑</h2><p>学完前面的几个章节后，我觉得有必要在这里带大家做一些练习来巩固之前所学的知识，虽然迄今为止我们学习的内容只是Python的冰山一角，但是这些内容已经足够我们来构建程序中的逻辑。对于编程语言的初学者来说，在学习了Python的核心语言元素（变量、类型、运算符、表达式、分支结构、循环结构等）之后，必须做的一件事情就是尝试用所学知识去解决现实中的问题，换句话说就是锻炼自己把用人类自然语言描述的算法（解决问题的方法和步骤）翻译成Python代码的能力，而这件事情必须通过大量的练习才能达成。</p>
<p>我们在本章为大家整理了一些经典的案例和习题，希望通过这些例子，一方面帮助大家巩固之前所学的Python知识，另一方面帮助大家了解如何建立程序中的逻辑以及如何运用一些简单的算法解决现实中的问题。</p>
<h3 id="经典的例子"><a href="#经典的例子" class="headerlink" title="经典的例子"></a>经典的例子</h3><ol>
<li><p>寻找<strong>水仙花数</strong>。</p>
<blockquote>
<p><strong>说明</strong>：水仙花数也被称为超完全数字不变数、自恋数、自幂数、阿姆斯特朗数，它是一个3位数，该数字每个位上数字的立方之和正好等于它本身，例如：$1^3 + 5^3+ 3^3=153$。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">找出所有水仙花数</span><br><span class="line"></span><br><span class="line">Version: 0.1</span><br><span class="line">Author: 骆昊</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">for num in range(100, 1000):</span><br><span class="line">    low &#x3D; num % 10</span><br><span class="line">    mid &#x3D; num &#x2F;&#x2F; 10 % 10</span><br><span class="line">    high &#x3D; num &#x2F;&#x2F; 100</span><br><span class="line">    if num &#x3D;&#x3D; low ** 3 + mid ** 3 + high ** 3:</span><br><span class="line">        print(num)</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们通过整除和求模运算分别找出了一个三位数的个位、十位和百位，这种小技巧在实际开发中还是常用的。用类似的方法，我们还可以实现将一个正整数反转，例如：将12345变成54321，代码如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">正整数的反转</span><br><span class="line"></span><br><span class="line">Version: 0.1</span><br><span class="line">Author: 骆昊</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">num &#x3D; int(input(&#39;num &#x3D; &#39;))</span><br><span class="line">reversed_num &#x3D; 0</span><br><span class="line">while num &gt; 0:</span><br><span class="line">    reversed_num &#x3D; reversed_num * 10 + num % 10</span><br><span class="line">    num &#x2F;&#x2F;&#x3D; 10</span><br><span class="line">print(reversed_num)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>百钱百鸡</strong>问题。</p>
<blockquote>
<p><strong>说明</strong>：百钱百鸡是我国古代数学家<a href="https://baike.baidu.com/item/张丘建/10246238" target="_blank" rel="noopener">张丘建</a>在《算经》一书中提出的数学问题：鸡翁一值钱五，鸡母一值钱三，鸡雏三值钱一。百钱买百鸡，问鸡翁、鸡母、鸡雏各几何？翻译成现代文是：公鸡5元一只，母鸡3元一只，小鸡1元三只，用100块钱买一百只鸡，问公鸡、母鸡、小鸡各有多少只？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">《百钱百鸡》问题</span><br><span class="line"></span><br><span class="line">Version: 0.1</span><br><span class="line">Author: 骆昊</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">for x in range(0, 20):</span><br><span class="line">    for y in range(0, 33):</span><br><span class="line">        z &#x3D; 100 - x - y</span><br><span class="line">        if 5 * x + 3 * y + z &#x2F; 3 &#x3D;&#x3D; 100:</span><br><span class="line">            print(&#39;公鸡: %d只, 母鸡: %d只, 小鸡: %d只&#39; % (x, y, z))</span><br></pre></td></tr></table></figure>

<p>上面使用的方法叫做<strong>穷举法</strong>，也称为<strong>暴力搜索法</strong>，这种方法通过一项一项的列举备选解决方案中所有可能的候选项并检查每个候选项是否符合问题的描述，最终得到问题的解。这种方法看起来比较笨拙，但对于运算能力非常强大的计算机来说，通常都是一个可行的甚至是不错的选择，而且问题的解如果存在，这种方法一定能够找到它。</p>
</li>
<li><p><strong>CRAPS赌博游戏</strong>。</p>
<blockquote>
<p><strong>说明</strong>：CRAPS又称花旗骰，是美国拉斯维加斯非常受欢迎的一种的桌上赌博游戏。该游戏使用两粒骰子，玩家通过摇两粒骰子获得点数进行游戏。简单的规则是：玩家第一次摇骰子如果摇出了7点或11点，玩家胜；玩家第一次如果摇出2点、3点或12点，庄家胜；其他点数玩家继续摇骰子，如果玩家摇出了7点，庄家胜；如果玩家摇出了第一次摇的点数，玩家胜；其他点数，玩家继续要骰子，直到分出胜负。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&quot;&quot;</span><br><span class="line">Craps赌博游戏</span><br><span class="line">我们设定玩家开始游戏时有1000元的赌注</span><br><span class="line">游戏结束的条件是玩家输光所有的赌注</span><br><span class="line"></span><br><span class="line">Version: 0.1</span><br><span class="line">Author: 骆昊</span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">from random import randint</span><br><span class="line"></span><br><span class="line">money &#x3D; 1000</span><br><span class="line">while money &gt; 0:</span><br><span class="line">    print(&#39;你的总资产为:&#39;, money)</span><br><span class="line">    needs_go_on &#x3D; False</span><br><span class="line">    while True:</span><br><span class="line">        debt &#x3D; int(input(&#39;请下注: &#39;))</span><br><span class="line">        if 0 &lt; debt &lt;&#x3D; money:</span><br><span class="line">            break</span><br><span class="line">    first &#x3D; randint(1, 6) + randint(1, 6)</span><br><span class="line">    print(&#39;玩家摇出了%d点&#39; % first)</span><br><span class="line">    if first &#x3D;&#x3D; 7 or first &#x3D;&#x3D; 11:</span><br><span class="line">        print(&#39;玩家胜!&#39;)</span><br><span class="line">        money +&#x3D; debt</span><br><span class="line">    elif first &#x3D;&#x3D; 2 or first &#x3D;&#x3D; 3 or first &#x3D;&#x3D; 12:</span><br><span class="line">        print(&#39;庄家胜!&#39;)</span><br><span class="line">        money -&#x3D; debt</span><br><span class="line">    else:</span><br><span class="line">        needs_go_on &#x3D; True</span><br><span class="line">    while needs_go_on:</span><br><span class="line">        needs_go_on &#x3D; False</span><br><span class="line">        current &#x3D; randint(1, 6) + randint(1, 6)</span><br><span class="line">        print(&#39;玩家摇出了%d点&#39; % current)</span><br><span class="line">        if current &#x3D;&#x3D; 7:</span><br><span class="line">            print(&#39;庄家胜&#39;)</span><br><span class="line">            money -&#x3D; debt</span><br><span class="line">        elif current &#x3D;&#x3D; first:</span><br><span class="line">            print(&#39;玩家胜&#39;)</span><br><span class="line">            money +&#x3D; debt</span><br><span class="line">        else:</span><br><span class="line">            needs_go_on &#x3D; True</span><br><span class="line">print(&#39;你破产了, 游戏结束!&#39;)</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>13-图像和办公文档处理</title>
    <url>/2019/10/02/tutorials/Python/13.%E5%9B%BE%E5%83%8F%E5%92%8C%E5%8A%9E%E5%85%AC%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h2 id="13-图像和办公文档处理"><a href="#13-图像和办公文档处理" class="headerlink" title="13-图像和办公文档处理"></a>13-图像和办公文档处理</h2><p>用程序来处理图像和办公文档经常出现在实际开发中，Python的标准库中虽然没有直接支持这些操作的模块，但我们可以通过Python生态圈中的第三方模块来完成这些操作。</p>
<h3 id="操作图像"><a href="#操作图像" class="headerlink" title="操作图像"></a>操作图像</h3><h4 id="计算机图像相关知识"><a href="#计算机图像相关知识" class="headerlink" title="计算机图像相关知识"></a>计算机图像相关知识</h4><ol>
<li><p>颜色。如果你有使用颜料画画的经历，那么一定知道混合红、黄、蓝三种颜料可以得到其他的颜色，事实上这三种颜色就是被我们称为美术三原色的东西，它们是不能再分解的基本颜色。在计算机中，我们可以将红、绿、蓝三种色光以不同的比例叠加来组合成其他的颜色，因此这三种颜色就是色光三原色，所以我们通常会将一个颜色表示为一个RGB值或RGBA值（其中的A表示Alpha通道，它决定了透过这个图像的像素，也就是透明度）。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">RGBA值</th>
<th align="center">名称</th>
<th align="center">RGBA值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">White</td>
<td align="center">(255, 255, 255, 255)</td>
<td align="center">Red</td>
<td align="center">(255, 0, 0, 255)</td>
</tr>
<tr>
<td align="center">Green</td>
<td align="center">(0, 255, 0, 255)</td>
<td align="center">Blue</td>
<td align="center">(0, 0, 255, 255)</td>
</tr>
<tr>
<td align="center">Gray</td>
<td align="center">(128, 128, 128, 255)</td>
<td align="center">Yellow</td>
<td align="center">(255, 255, 0, 255)</td>
</tr>
<tr>
<td align="center">Black</td>
<td align="center">(0, 0, 0, 255)</td>
<td align="center">Purple</td>
<td align="center">(128, 0, 128, 255)</td>
</tr>
</tbody></table>
</li>
<li><p>像素。对于一个由数字序列表示的图像来说，最小的单位就是图像上单一颜色的小方格，这些小方块都有一个明确的位置和被分配的色彩数值，而这些一小方格的颜色和位置决定了该图像最终呈现出来的样子，它们是不可分割的单位，我们通常称之为像素（pixel）。每一个图像都包含了一定量的像素，这些像素决定图像在屏幕上所呈现的大小。</p>
</li>
</ol>
<h4 id="用Pillow操作图像"><a href="#用Pillow操作图像" class="headerlink" title="用Pillow操作图像"></a>用Pillow操作图像</h4><p>Pillow是由从著名的Python图像处理库PIL发展出来的一个分支，通过Pillow可以实现图像压缩和图像处理等各种操作。可以使用下面的命令来安装Pillow。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install pillow</span><br></pre></td></tr></table></figure>

<p>Pillow中最为重要的是Image类，读取和处理图像都要通过这个类来完成。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.format, image.size, image.mode</span><br><span class="line">(<span class="string">'JPEG'</span>, (<span class="number">500</span>, <span class="number">750</span>), <span class="string">'RGB'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-show.png" alt=""></p>
<ol>
<li><p>剪裁图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect = <span class="number">80</span>, <span class="number">20</span>, <span class="number">310</span>, <span class="number">360</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.crop(rect).show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-crop.png" alt=""></p>
</li>
<li><p>生成缩略图</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>size = <span class="number">128</span>, <span class="number">128</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.thumbnail(size)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-thumbnail.png" alt=""></p>
</li>
<li><p>缩放和黏贴图像</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>image1 = Image.open(<span class="string">'./res/luohao.png'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image2 = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>rect = <span class="number">80</span>, <span class="number">20</span>, <span class="number">310</span>, <span class="number">360</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>guido_head = image2.crop(rect)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>width, height = guido_head.size</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image1.paste(guido_head.resize((int(width / <span class="number">1.5</span>), int(height / <span class="number">1.5</span>))), (<span class="number">172</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-paste.png" alt=""></p>
</li>
<li><p>旋转和翻转</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.png'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.rotata(<span class="number">180</span>).show()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.transpose(Image.FLIP_LEFT_RIGHT).show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-rotate.png" alt=""></p>
<p><img src="./res/image-transpose.png" alt=""></p>
</li>
<li><p>操作像素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">80</span>, <span class="number">310</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">20</span>, <span class="number">360</span>):</span><br><span class="line"><span class="meta">... </span>        image.putpixel((x, y), (<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-putpixel.png" alt=""></p>
</li>
<li><p>滤镜效果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFilter</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = Image.open(<span class="string">'./res/guido.jpg'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.filter(ImageFilter.CONTOUR).show()</span><br></pre></td></tr></table></figure>

<p><img src="./res/image-filter.png" alt=""></p>
</li>
</ol>
<h3 id="处理Excel电子表格"><a href="#处理Excel电子表格" class="headerlink" title="处理Excel电子表格"></a>处理Excel电子表格</h3><p>Python的openpyxl模块让我们可以在Python程序中读取和修改Excel电子表格，当然实际工作中，我们可能会用LibreOffice Calc和OpenOffice Calc来处理Excel的电子表格文件，这就意味着openpyxl模块也能处理来自这些软件生成的电子表格。关于openpyxl的使用手册和使用文档可以查看它的<a href="https://openpyxl.readthedocs.io/en/stable/#" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="处理Word文档"><a href="#处理Word文档" class="headerlink" title="处理Word文档"></a>处理Word文档</h3><p>利用python-docx模块，Pytho 可以创建和修改Word文档，当然这里的Word文档不仅仅是指通过微软的Office软件创建的扩展名为docx的文档，LibreOffice Writer和OpenOffice Writer都是免费的字处理软件。</p>
<h3 id="处理PDF文档"><a href="#处理PDF文档" class="headerlink" title="处理PDF文档"></a>处理PDF文档</h3><p>PDF是Portable Document Format的缩写，使用.pdf作为文件扩展名。接下来我们就研究一下如何通过Python实现从PDF读取文本内容和从已有的文档生成新的PDF文件。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>15-网络应用开发</title>
    <url>/2019/10/02/tutorials/Python/15.%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h2 id="15-网络应用开发"><a href="#15-网络应用开发" class="headerlink" title="15-网络应用开发"></a>15-网络应用开发</h2><h3 id="发送电子邮件"><a href="#发送电子邮件" class="headerlink" title="发送电子邮件"></a>发送电子邮件</h3><p>在即时通信软件如此发达的今天，电子邮件仍然是互联网上使用最为广泛的应用之一，公司向应聘者发出录用通知、网站向用户发送一个激活账号的链接、银行向客户推广它们的理财产品等几乎都是通过电子邮件来完成的，而这些任务应该都是由程序自动完成的。</p>
<p>就像我们可以用HTTP（超文本传输协议）来访问一个网站一样，发送邮件要使用SMTP（简单邮件传输协议），SMTP也是一个建立在TCP（传输控制协议）提供的可靠数据传输服务的基础上的应用级协议，它规定了邮件的发送者如何跟发送邮件的服务器进行通信的细节，而Python中的smtplib模块将这些操作简化成了几个简单的函数。</p>
<p>下面的代码演示了如何在Python发送邮件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 请自行修改下面的邮件发送者和接收者</span></span><br><span class="line">    sender = <span class="string">'abcdefg@126.com'</span></span><br><span class="line">    receivers = [<span class="string">'uvwxyz@qq.com'</span>, <span class="string">'uvwxyz@126.com'</span>]</span><br><span class="line">    message = MIMEText(<span class="string">'用Python发送邮件的示例代码.'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'From'</span>] = Header(<span class="string">'王大锤'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'To'</span>] = Header(<span class="string">'骆昊'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(<span class="string">'示例代码实验邮件'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    smtper = SMTP(<span class="string">'smtp.126.com'</span>)</span><br><span class="line">    <span class="comment"># 请自行修改下面的登录口令</span></span><br><span class="line">    smtper.login(sender, <span class="string">'secretpass'</span>)</span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    print(<span class="string">'邮件发送完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>如果要发送带有附件的邮件，那么可以按照下面的方式进行操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> smtplib <span class="keyword">import</span> SMTP</span><br><span class="line"><span class="keyword">from</span> email.header <span class="keyword">import</span> Header</span><br><span class="line"><span class="keyword">from</span> email.mime.text <span class="keyword">import</span> MIMEText</span><br><span class="line"><span class="keyword">from</span> email.mime.image <span class="keyword">import</span> MIMEImage</span><br><span class="line"><span class="keyword">from</span> email.mime.multipart <span class="keyword">import</span> MIMEMultipart</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建一个带附件的邮件消息对象</span></span><br><span class="line">    message = MIMEMultipart()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建文本内容</span></span><br><span class="line">    text_content = MIMEText(<span class="string">'附件中有本月数据请查收'</span>, <span class="string">'plain'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    message[<span class="string">'Subject'</span>] = Header(<span class="string">'本月数据'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment"># 将文本内容添加到邮件消息对象中</span></span><br><span class="line">    message.attach(text_content)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取文件并将文件作为附件添加到邮件消息对象中</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/Hao/Desktop/hello.txt'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        txt = MIMEText(f.read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">        txt[<span class="string">'Content-Type'</span>] = <span class="string">'text/plain'</span></span><br><span class="line">        txt[<span class="string">'Content-Disposition'</span>] = <span class="string">'attachment; filename=hello.txt'</span></span><br><span class="line">        message.attach(txt)</span><br><span class="line">    <span class="comment"># 读取文件并将文件作为附件添加到邮件消息对象中</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/Hao/Desktop/汇总数据.xlsx'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        xls = MIMEText(f.read(), <span class="string">'base64'</span>, <span class="string">'utf-8'</span>)</span><br><span class="line">        xls[<span class="string">'Content-Type'</span>] = <span class="string">'application/vnd.ms-excel'</span></span><br><span class="line">        xls[<span class="string">'Content-Disposition'</span>] = <span class="string">'attachment; filename=month-data.xlsx'</span></span><br><span class="line">        message.attach(xls)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建SMTP对象</span></span><br><span class="line">    smtper = SMTP(<span class="string">'smtp.126.com'</span>)</span><br><span class="line">    <span class="comment"># 开启安全连接</span></span><br><span class="line">    <span class="comment"># smtper.starttls()</span></span><br><span class="line">    sender = <span class="string">'abcdefg@126.com'</span></span><br><span class="line">    receivers = [<span class="string">'uvwxyz@qq.com'</span>]</span><br><span class="line">    <span class="comment"># 登录到SMTP服务器</span></span><br><span class="line">    <span class="comment"># 请注意此处不是使用密码而是邮件客户端授权码进行登录</span></span><br><span class="line">    <span class="comment"># 对此有疑问的读者可以联系自己使用的邮件服务器客服</span></span><br><span class="line">    smtper.login(sender, <span class="string">'secretpass'</span>)</span><br><span class="line">    <span class="comment"># 发送邮件</span></span><br><span class="line">    smtper.sendmail(sender, receivers, message.as_string())</span><br><span class="line">    <span class="comment"># 与邮件服务器断开连接</span></span><br><span class="line">    smtper.quit()</span><br><span class="line">    print(<span class="string">'发送完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="发送短信"><a href="#发送短信" class="headerlink" title="发送短信"></a>发送短信</h3><p>发送短信也是项目中常见的功能，网站的注册码、验证码、营销信息基本上都是通过短信来发送给用户的。在下面的代码中我们使用了<a href="http://www.ihuyi.com/" target="_blank" rel="noopener">互亿无线</a>短信平台（该平台为注册用户提供了50条免费短信以及常用开发语言发送短信的demo，可以登录该网站并在用户自服务页面中对短信进行配置）提供的API接口实现了发送短信的服务，当然国内的短信平台很多，读者可以根据自己的需要进行选择（通常会考虑费用预算、短信达到率、使用的难易程度等指标），如果需要在商业项目中使用短信服务建议购买短信平台提供的套餐服务。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"><span class="keyword">import</span> http.client</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    host  = <span class="string">"106.ihuyi.com"</span></span><br><span class="line">    sms_send_uri = <span class="string">"/webservice/sms.php?method=Submit"</span></span><br><span class="line">    <span class="comment"># 下面的参数需要填入自己注册的账号和对应的密码</span></span><br><span class="line">    params = urllib.parse.urlencode(&#123;<span class="string">'account'</span>: <span class="string">'你自己的账号'</span>, <span class="string">'password'</span> : <span class="string">'你自己的密码'</span>, <span class="string">'content'</span>: <span class="string">'您的验证码是：147258。请不要把验证码泄露给其他人。'</span>, <span class="string">'mobile'</span>: <span class="string">'接收者的手机号'</span>, <span class="string">'format'</span>:<span class="string">'json'</span> &#125;)</span><br><span class="line">    print(params)</span><br><span class="line">    headers = &#123;<span class="string">'Content-type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>, <span class="string">'Accept'</span>: <span class="string">'text/plain'</span>&#125;</span><br><span class="line">    conn = http.client.HTTPConnection(host, port=<span class="number">80</span>, timeout=<span class="number">30</span>)</span><br><span class="line">    conn.request(<span class="string">'POST'</span>, sms_send_uri, params, headers)</span><br><span class="line">    response = conn.getresponse()</span><br><span class="line">    response_str = response.read()</span><br><span class="line">    jsonstr = response_str.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    print(json.loads(jsonstr))</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux002 Bash基础</title>
    <url>/2019/11/13/tutorials/Linux/Linux002/</url>
    <content><![CDATA[<h1 id="Bash的基本使用"><a href="#Bash的基本使用" class="headerlink" title="Bash的基本使用"></a>Bash的基本使用</h1><blockquote>
<p>在前面我们完成了Linux系统的基本安装，有的操作系统（如Ubuntu Manjaro Debian等）有 完整的图形界面 和 各种各样的 <code>GUI（Graphical User Interface，简称 GUI，又称图形用户接口）</code>工具。我们一下就能联想到windows的操作方式，所以你能快速上手这种linux发行版。但是，Linux真正的魅力在于一个看起来十分简陋，功能却异常强大的不起眼的小应用程序——Shell.本节我们就讲讲目前几乎所有发行版都预装的Shell的一种——<code>Bash Shell</code>。  </p>
</blockquote>
<p>我们不讲各个发行版是怎样开机，登录的具体使用步骤，我相信你们有能力自己完成这些简单的click动作。</p>
<a id="more"></a>

<h2 id="我们先说说Shell"><a href="#我们先说说Shell" class="headerlink" title="我们先说说Shell"></a>我们先说说Shell</h2><p>我们先直接抛出<code>shell</code>的定义，来源参考百度百科。</p>
<p><code>shell</code> 是文字操作系统与外部最主要的接口。它是操作系统最外面的一层。shell管理你与<code>操作系统</code>之间的交互：等待你输入，向操作系统解释你的输入，并且处理各种各样的操作系统的输出结果。（还记得我们第一节课讲的操作系统就是一个<strong>翻译官</strong>吗？ 他其实更像一个大独裁者。Shell 是他的眼睛，耳朵，鼻子，嘴巴）。<br>我们给 操作系统（一个翻译官） 说我们想要干嘛，比如我们说 “播放我存放在d盘的电影《大话西游》”。这个翻译官通过耳朵（Shell）“听到”了我们的话，然后他就命令计算机说：</p>
<blockquote>
<p>“##%@￥&amp;￥%@￥%#<em>&amp;￥……%#&amp;￥@￥#…………&amp;*￥#……￥&amp;@@%？?&gt;{:&lt;?”|}}{::&gt;?++_</em>&amp;$#%%!~!*(((&amp;%@!!” （此处省略10k个字符）</p>
</blockquote>
<p>来，让我给你翻译一下，就是 </p>
<blockquote>
<p>“去，把你磁盘上9527区的007到008分段的数据传输给 爱奇艺 ，爱奇艺，我再给你调用2个cpu的权限，你给我把画面播放到那个显示器上。”</p>
</blockquote>
<p>总结一下，就是 操作系统通过耳朵（Shell）听我们给他的命令，然后他去用只有计算机硬件懂得的语言（当然我也懂，不然你就看不到上面那段人性化的翻译了）去命令计算机该怎么做。这些cpu，磁盘，显示器，音响都是操作系统的小弟，全由操作系统指挥。</p>
<p>其实Shell不仅仅是去”听”，他同时也能输出。在后续的实际操作我会给大家演示。</p>
<p><code>Shell</code>大概就是这样，他是操作系统的最外部一层，用来管理我们和操作系统之间的交互。如果不把计算机内部细化。Shell也就是直接 <strong><em>管理人和机器的交互</em></strong> 的工具</p>
<p>Shell到后来又有了很多不同的版本出来，比如现在很出名的bash，zsh，其他的还有诸如sh，ksh，csh等等，你也可以在一个linux系统上安装很多不同的shell，不过今天我们不在这儿说怎样更换。因为还需一些其他的基础知识，不过我们还没有提。所以先缓缓。。</p>
<blockquote>
<p>很有必要讲一讲的是，shell和GUI的关系，要知道shell是早于GUI桌面应用很早很早之前就出来了的。你的电脑能做的事，都可以通过shell做到，而你的GUI桌面则不然，所以说，Shell的能力是&gt;&gt;&gt;&gt;GUI桌面的。学习shell也就很重要了。</p>
</blockquote>
<h2 id="Bash"><a href="#Bash" class="headerlink" title="$ Bash"></a>$ Bash</h2><p>Bash啊，他是Shell的一种，目前的绝大多数Linux发行版都把Bash作为默认Shell。Bash的功能也比sh（shell的第一个版本）强大很多。</p>
<blockquote>
<p>在图形界面完备的Linux发行版中（如Ubuntu），你需要打开叫做<code>Terminal</code>(终端)的应用程序来操作Shell。</p>
<p>简述：终端干的活儿是从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。而 Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。更多内容，包括 terminal Shell tty 之间的联系和差别，<a href="https://www.cnblogs.com/sddai/p/9769086.html" target="_blank" rel="noopener">请移步此链接</a></p>
</blockquote>
<p>Bash和其他shell看起来差不多相同，黑底白字，偶尔出现漂亮鲜艳的红色（你绝对不会喜欢bash下出现红色的字的）。他大概长这样子，你看到的这整个框体就是terminal，里面的内容就是Bash了。</p>
<p><img src="bash.png" alt=""></p>
<p>我们来看他的组成</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$</span><br></pre></td></tr></table></figure>
<p>前面第一个字符串<code>vvenzhou</code>是你登陆的用户名</p>
<ul>
<li><strong>@</strong> 符号后面的<code>ubuntu</code>是你的计算机hostname，也就是计算机名</li>
<li><strong>：</strong> 后面的是shell现在所处的目录位置（这里的<code>~</code>就是指当前的用户目录）</li>
<li><strong>$</strong>  后面就是你输入shell命令的地方</li>
</ul>
<h3 id="初识命令（command）"><a href="#初识命令（command）" class="headerlink" title="初识命令（command）"></a>初识命令（command）</h3><p>下面有一些常用的shell命令（我相信你们都能看懂初中英语吧）<br><img src="commands.png" alt=""><br>我们试着输入一些命令，看看shell有什么反应</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls</span><br></pre></td></tr></table></figure>
<p><img src="ls.png" alt=""></p>
<p><code>ls</code>命令表示显示出当前目录下的文件。还记得当前目录是怎么看的吗？</p>
<p>一般的，一个新的Linux系统会自动在用户目录下创建好这么几个目录（windows下叫做文件夹）（folder）。</p>
<p>shell命令有的只需要单独command名就行了，如上面的<code>ls</code>，然而还可以在后面带上参数（arguments），<strong><em>命令和参数之间用空格分开</em></strong> 。比如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls Pictures</span><br></pre></td></tr></table></figure>
<p><img src="ls_01.png" alt=""></p>
<p>这表明 显示 <em>当前目录</em> 下的 <em>Pictures</em>目录下的文件。即 <code>~/Pictures/</code><br>你也可以直接跟一个完整的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls ~/Pictures</span><br></pre></td></tr></table></figure>
<p><img src="ls_02.png" alt=""></p>
<p>如果路径不正确（目录不存在）呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls ~/Pict</span><br></pre></td></tr></table></figure>
<p><img src="ls_03.png" alt=""></p>
<p>shell会返回错误信息。</p>
<p>然而<code>ls</code>还能做更多的东西，你可以在命令后面加指定的option来实现更多的功能，试试在 <code>ls</code> 后面加上 <code>-a</code> （缩写） 或者 <code>--all</code> （全称）<br><strong><em>同理，command option argument之间都要用空格分开</em></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls -a</span><br></pre></td></tr></table></figure>
<p><img src="ls_04.png" alt=""></p>
<p>看！他显示了更多的东西。不仅有那些目录，还有更多的其他东西。<br><code>ls</code> 默认只显示那些不是<code>.</code>开头的文件和目录。但是你可以加上<code>-a</code> option来告诉<code>ls</code>你想看到更多。</p>
<p>你还可以把好多option写在一起，试试用<code>ls -al</code>代替<code>ls -a -l</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vvenzhou@ubuntu:~$ ls -al</span><br></pre></td></tr></table></figure>
<p><img src="ls_05.png" alt=""><br>（至于-l option的作用我暂时不讲）</p>
<p>这些就是命令（command）的基本使用方法。现在去自己的Linux上试试上面那个表中的命令吧，更多命令及使用方法<a href="https://osa-null.github.io/[object%20Object]/Linux/Linux_general/">请移步本系列教程的另一个帖子</a>。<strong>注意要细心观察输入了命令后的种种变化</strong>。</p>
<p>如果你不知道某个命令该怎么用，有哪些option，需要什么argument，请使用<code>man</code> 命令，如<code>man ls</code> <code>man man</code>。要退出 man 请注意终端下方的高亮提示。</p>
<p>Linux是个高度自由的操作系统，也请大家多多锻炼动手能力，自己发现错误，找到错误，解决错误的过程才是你真正学习Linux知识的时候。</p>
<p>Linux学习之路的3条建议</p>
<ul>
<li>善用man命令</li>
<li>善用 <a href="https://www.baidu.com" target="_blank" rel="noopener">Baidu</a> <a href="https://www.bing.com" target="_blank" rel="noopener">Bing</a> 以及<a href="https://www.google.com" target="_blank" rel="noopener">某404网站</a>。</li>
<li>学好英语</li>
</ul>
<p>如果你去各个渠道都找不到解决办法，欢迎来找我或者其他人，虽然我肯定也不会（你在网上都找不到了，我也一定找不到），但我们可以一起来尝试解决它。交流出真知，别忘了，我们有强大的开源社区！！！</p>
<blockquote>
<p>more tips：shell可以运行的不仅仅是一些自带命令哦，所有可执行文件（通俗的说就是应用程序）都可以通过shell打开。</p>
</blockquote>
<h3 id="One-more-thing"><a href="#One-more-thing" class="headerlink" title="One more thing"></a>One more thing</h3><p>上面讲的那些我相信大家都很容易就明白了，而且确实也不难，不如我们就再加一点点料，补充一点理论知识。我们就讲讲Linux的文件系统，这就涉及到了Linux的一个理念——<strong><em>万物皆是文件</em></strong></p>
<h4 id="Everything-is-a-file"><a href="#Everything-is-a-file" class="headerlink" title="Everything is a file"></a>Everything is a file</h4><blockquote>
<p>“On a UNIX system, everything is a file; if something is not a file, it is a process.”</p>
</blockquote>
<p>Linux 中所有内容都是以文件的形式保存和管理的，即一切皆文件，普通文件是文件，目录（Windows 下称为文件夹）是文件，硬件设备（键盘、监视器、硬盘、打印机）是文件，就连套接字（socket）、网络通信等资源也都是文件。</p>
<p>那么问题来了，要如何来管理这些庞大的各类文件呢？</p>
<p>树！</p>
<p>树其实很简单，就是长得像树的一种文件系统，首先是根目录<code>/</code>，这是唯一的，你可以理解成所有目录的老大，没有谁能在他之上（之前）了。根目录下面便是各类子目录，具体见下图。</p>
<p><img src="file_system.png" alt="file system"></p>
<p>每个目录都有他们特定的功能，比如<br><img src="partition.png" alt="partition"></p>
<p>记得<code>~</code>这个地址吗？如果我登录的用户名是<code>wenzhou</code>，那么这个波浪线的完整地址其实就是<code>/home/wenzhou/</code>，那里就是存我这个用户的资料的，比如我下载了什么电影，音乐，电子书，都应该放在自己的用户目录下，以免造成磁盘文件的混乱。</p>
<blockquote>
<p>如果你想要知道你当前所在目录的完整地址，除了看shell前面的那一坨东西之外，也可以用<code>pwd</code>命令来查看，去试试。</p>
</blockquote>
<blockquote>
<p>还有，注意<code>/root</code>和<code>/</code>，他两肯定不一样，但是我们读起来都是读的 “gen mu lu” ，要注意区分他俩，别混淆了。</p>
</blockquote>
<p>更多的细节：（我就不翻译了）<br><img src="partitions_desc.png" alt="more details"></p>
<p>Well, bash基础和Linux文件系统大概就讲这些，更具体的可以查看我们发到群里的intro-linx.pdf获取更多知识。</p>
<p>goodbye！</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>01 - 初识Python</title>
    <url>/2019/10/02/tutorials/Python/01.%E5%88%9D%E8%AF%86Python/</url>
    <content><![CDATA[<h2 id="01-初识Python"><a href="#01-初识Python" class="headerlink" title="01 - 初识Python"></a>01 - 初识Python</h2><h3 id="Python简介"><a href="#Python简介" class="headerlink" title="Python简介"></a>Python简介</h3><h4 id="Python的历史"><a href="#Python的历史" class="headerlink" title="Python的历史"></a>Python的历史</h4><ol>
<li>1989年圣诞节：Guido von Rossum开始写Python语言的编译器。</li>
<li>1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面又出现了Java和C#实现的版本Jython和IronPython，以及PyPy、Brython、Pyston等其他实现），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，同时提供了“列表”和“字典”等核心数据类型，同时支持以模块为基础的拓展系统。</li>
<li>1994年1月：Python 1.0正式发布。</li>
<li>2000年10月16日：Python 2.0发布，增加了实现完整的<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">垃圾回收</a>，提供了对<a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a>的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。</li>
<li>2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。</li>
</ol>
<p>目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（如修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以查看一篇名为<a href="http://www.cnblogs.com/vamei/archive/2013/02/06/2892628.html" target="_blank" rel="noopener">《Python简史》</a>的博文。</p>
<h4 id="Python的优缺点"><a href="#Python的优缺点" class="headerlink" title="Python的优缺点"></a>Python的优缺点</h4><p>Python的优点很多，简单的可以总结为以下几点。</p>
<ol>
<li>简单和明确，做一件事只有一种方法。</li>
<li>学习曲线低，跟其他很多语言相比，Python更容易上手。</li>
<li>开放源代码，拥有强大的社区和生态圈。</li>
<li>解释型语言，天生具有平台可移植性。</li>
<li>支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。</li>
<li>可扩展性和可嵌入性，可以调用C/C++代码，也可以在C/C++中调用Python。</li>
<li>代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。</li>
</ol>
<p>Python的缺点主要集中在以下几点。</p>
<ol>
<li>执行效率稍低，因此计算密集型任务可以由C/C++编写。</li>
<li>代码无法加密，但是现在的公司很多都不是卖软件而是卖服务，这个问题会被淡化。</li>
<li>在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。</li>
</ol>
<h4 id="Python的应用领域"><a href="#Python的应用领域" class="headerlink" title="Python的应用领域"></a>Python的应用领域</h4><p>目前Python在云基础设施、DevOps、网络爬虫开发、数据分析挖掘、机器学习等领域都有着广泛的应用，因此也产生了Web后端开发、数据接口开发、自动化运维、自动化测试、科学计算和可视化、数据分析、量化交易、机器人开发、图像识别和处理等一系列的职位。</p>
<h3 id="搭建编程环境"><a href="#搭建编程环境" class="headerlink" title="搭建编程环境"></a>搭建编程环境</h3><h4 id="Windows环境"><a href="#Windows环境" class="headerlink" title="Windows环境"></a>Windows环境</h4><p>可以在<a href="https://www.python.org" target="_blank" rel="noopener">Python官方网站</a>下载到Python的Windows安装程序（exe文件），需要注意的是如果在Windows 7环境下安装需要先安装Service Pack 1补丁包（可以通过一些工具软件自动安装系统补丁的功能来安装），安装过程建议勾选“Add Python 3.6 to PATH”（将Python 3.6添加到PATH环境变量）并选择自定义安装，在设置“Optional Features”界面最好将“pip”、“tcl/tk”、“Python test suite”等项全部勾选上。强烈建议使用自定义的安装路径并保证路径中没有中文。安装完成会看到“Setup was successful”的提示，但是在启动Python环境时可能会因为缺失一些动态链接库文件而导致Python解释器无法运行，常见的问题主要是api-ms-win-crt*.dll缺失以及更新DirectX之后导致某些动态链接库文件缺失，前者可以参照<a href="">《api-ms-win-crt*.dll缺失原因分析和解决方法》</a>一文讲解的方法进行处理或者直接在<a href="https://www.microsoft.com/zh-cn/download/details.aspx?id=48145">微软官网</a>下载Visual C++ Redistributable for Visual Studio 2015文件进行修复，后者可以下载一个DirectX修复工具进行修复。</p>
<h4 id="Linux环境"><a href="#Linux环境" class="headerlink" title="Linux环境"></a>Linux环境</h4><p>Linux环境自带了Python 2.x版本，但是如果要更新到3.x的版本，可以在<a href="https://www.python.org" target="_blank" rel="noopener">Python的官方网站</a>下载Python的源代码并通过源代码构建安装的方式进行安装，具体的步骤如下所示。</p>
<p>安装依赖库（因为没有这些依赖库可能在源代码构件安装时因为缺失底层依赖库而失败）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install wget gcc zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel libffi-devel</span><br></pre></td></tr></table></figure>

<p>下载Python源代码并解压缩到指定目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.3/Python-3.7.3.tgz</span><br><span class="line">xz -d Python-3.7.3.tar.xz</span><br><span class="line">tar -xvf Python-3.7.3.tar</span><br></pre></td></tr></table></figure>

<p>切换至Python源代码目录并执行下面的命令进行配置和安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd Python-3.7.3</span><br><span class="line">./configure --prefix=/usr/local/python37 --enable-optimizations</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>

<p>修改用户主目录下名为.bash_profile的文件，配置PATH环境变量并使其生效。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">vim .bash_profile</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ... 此处省略上面的代码 ...</span></span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/local/python37/bin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ... 此处省略下面的代码 ...</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source .bash_profile</span><br></pre></td></tr></table></figure>

<h4 id="MacOS环境"><a href="#MacOS环境" class="headerlink" title="MacOS环境"></a>MacOS环境</h4><p>MacOS也是自带了Python 2.x版本的，可以通过<a href="https://www.python.org" target="_blank" rel="noopener">Python的官方网站</a>提供的安装文件（pkg文件）安装3.x的版本。默认安装完成后，可以通过在终端执行python命令来启动2.x版本的Python解释器，可以通过执行python3命令来启动3.x版本的Python解释器。</p>
<h3 id="从终端运行Python程序"><a href="#从终端运行Python程序" class="headerlink" title="从终端运行Python程序"></a>从终端运行Python程序</h3><h4 id="确认Python的版本"><a href="#确认Python的版本" class="headerlink" title="确认Python的版本"></a>确认Python的版本</h4><p>在终端或命令行提示符中键入下面的命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python --version</span><br></pre></td></tr></table></figure>
<p>当然也可以先输入python进入交互式环境，再执行以下的代码检查Python的版本。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.version_info)</span><br><span class="line">print(sys.version)</span><br></pre></td></tr></table></figure>

<h4 id="编写Python源代码"><a href="#编写Python源代码" class="headerlink" title="编写Python源代码"></a>编写Python源代码</h4><p>可以用文本编辑工具（推荐使用Sublime、Atom、TextMate、VSCode等高级文本编辑工具）编写Python源代码并将其命名为hello.py保存起来，代码内容如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello, world!'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>切换到源代码所在的目录并执行下面的命令，看看屏幕上是否输出了”hello, world!”。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python hello.py</span><br></pre></td></tr></table></figure>

<h3 id="代码中的注释"><a href="#代码中的注释" class="headerlink" title="代码中的注释"></a>代码中的注释</h3><p>注释是编程语言的一个重要组成部分，用于在源代码中解释代码的作用从而增强程序的可读性和可维护性，当然也可以将源代码中不需要参与运行的代码段通过注释来去掉，这一点在调试程序的时候经常用到。注释在随源代码进入预处理器或编译时会被移除，不会在目标代码中保留也不会影响程序的执行结果。</p>
<ol>
<li>单行注释 - 以#和空格开头的部分</li>
<li>多行注释 - 三个引号开头，三个引号结尾</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第一个Python程序 - hello, world!</span></span><br><span class="line"><span class="string">向伟大的Dennis M. Ritchie先生致敬</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'hello, world!'</span>)</span><br><span class="line"><span class="comment"># print("你好,世界！")</span></span><br><span class="line">print(<span class="string">'你好'</span>, <span class="string">'世界'</span>)</span><br><span class="line">print(<span class="string">'hello'</span>, <span class="string">'world'</span>, sep=<span class="string">', '</span>, end=<span class="string">'!'</span>)</span><br><span class="line">print(<span class="string">'goodbye, world'</span>, end=<span class="string">'!\n'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="其他工具介绍"><a href="#其他工具介绍" class="headerlink" title="其他工具介绍"></a>其他工具介绍</h3><h4 id="IDLE-自带的集成开发工具"><a href="#IDLE-自带的集成开发工具" class="headerlink" title="IDLE - 自带的集成开发工具"></a>IDLE - 自带的集成开发工具</h4><p>IDLE是安装Python环境时自带的集成开发工具，如下图所示。但是由于IDLE的用户体验并不是那么好所以很少在实际开发中被采用。</p>
<p><img src="./res/python-idle.png" alt=""></p>
<h4 id="IPython-更好的交互式编程工具"><a href="#IPython-更好的交互式编程工具" class="headerlink" title="IPython - 更好的交互式编程工具"></a>IPython - 更好的交互式编程工具</h4><p>IPython是一种基于Python的交互式解释器。相较于原生的Python Shell，IPython提供了更为强大的编辑和交互功能。可以通过Python的包管理工具pip安装IPython和Jupyter，具体的操作如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install ipython jupyter</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python -m pip install ipython jupyter</span><br></pre></td></tr></table></figure>

<p>安装成功后，可以通过下面的ipython命令启动IPython，如下图所示。</p>
<p><img src="./res/python-ipython.png" alt=""></p>
<p>当然我们也可以通过Jupyter运行名为notebook的项目在浏览器窗口中进行交互式操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">jupyter notebook</span><br></pre></td></tr></table></figure>

<p><img src="./res/python-jupyter-2.png" alt=""></p>
<h4 id="anaconda-一站式的数据科学神器"><a href="#anaconda-一站式的数据科学神器" class="headerlink" title="anaconda - 一站式的数据科学神器"></a>anaconda - 一站式的数据科学神器</h4><p>Anaconda指的是一个开源的Python发行版本，其包含了conda、Python等180多个科学包及其依赖项。<br>因为包含了大量的科学包，Anaconda 的下载文件比较大（约 531 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用Miniconda这个较小的发行版（仅包含conda和 Python）。<br>对于学习数据科学的人来说，anaconda是绝对的神器，安装简便，而且anaconda支持安装相关软件【例如前文提到的ipython，jupyter notebook，甚至有R等其他数据科学软件 】<br><a href="https://www.jianshu.com/p/169403f7e40c" target="_blank" rel="noopener">一个相当有价值的介绍</a><br>现在唯一的问题在于清华镜像服务已经关闭，跨国下载会比较慢</p>
<h4 id="Sublime-文本编辑神器"><a href="#Sublime-文本编辑神器" class="headerlink" title="Sublime - 文本编辑神器"></a>Sublime - 文本编辑神器</h4><p><img src="./res/python-sublime.png" alt=""></p>
<ul>
<li><p>首先可以通过<a href="https://www.sublimetext.com/" target="_blank" rel="noopener">官方网站</a>下载安装程序安装Sublime 3或Sublime 2。</p>
</li>
<li><p>安装包管理工具。通过快捷键Ctrl+`或者在View菜单中选择Show Console打开控制台，输入下面的代码。</p>
<ul>
<li>Sublime 3</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  urllib.request,os;pf=<span class="string">'Package Control.sublime-package'</span>;ipp=sublime.installed_packages_path();urllib.request.install_opener(urllib.request.build_opener(urllib.request.ProxyHandler()));open(os.path.join(ipp,pf),<span class="string">'wb'</span>).write(urllib.request.urlopen(<span class="string">'http://sublime.wbond.net/'</span>+pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure>

<ul>
<li>Sublime 2</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span>  urllib2,os;pf=<span class="string">'Package Control.sublime-package'</span>;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnotos.path.exists(ipp)elseNone;urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()));open(os.path.join(ipp,pf),<span class="string">'wb'</span>).write(urllib2.urlopen(<span class="string">'http://sublime.wbond.net/'</span>+pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read());print(<span class="string">'Please restart Sublime Text to finish installation'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装插件。通过Preference菜单的Package Control或快捷键Ctrl+Shift+P打开命令面板，在面板中输入Install Package就可以找到安装插件的工具，然后再查找需要的插件。我们推荐大家安装以下几个插件：</p>
<ul>
<li>SublimeCodeIntel - 代码自动补全工具插件。</li>
<li>Emmet - 前端开发代码模板插件。</li>
<li>Git - 版本控制工具插件。</li>
<li>Python PEP8 Autoformat - PEP8规范自动格式化插件。</li>
<li>ConvertToUTF8 - 将本地编码转换为UTF-8。</li>
</ul>
</li>
</ul>
<h4 id="PyCharm-Python开发神器"><a href="#PyCharm-Python开发神器" class="headerlink" title="PyCharm - Python开发神器"></a>PyCharm - Python开发神器</h4><p>PyCharm的安装、配置和使用我们在后面会进行介绍。</p>
<p><img src="./res/python-pycharm.png" alt=""></p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol>
<li><p>在Python交互环境中查看下面的代码结果，并将内容翻译成中文。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure>
</li>
<li><p>学习使用turtle在屏幕上绘制图形。</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">turtle.pensize(<span class="number">4</span>)</span><br><span class="line">turtle.pencolor(<span class="string">'red'</span>)</span><br><span class="line">turtle.forward(<span class="number">100</span>)</span><br><span class="line">turtle.right(<span class="number">90</span>)</span><br><span class="line">turtle.forward(<span class="number">100</span>)</span><br><span class="line">turtle.right(<span class="number">90</span>)</span><br><span class="line">turtle.forward(<span class="number">100</span>)</span><br><span class="line">turtle.right(<span class="number">90</span>)</span><br><span class="line">turtle.forward(<span class="number">100</span>)</span><br><span class="line">turtle.mainloop()</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>02 - 语言元素</title>
    <url>/2019/10/02/tutorials/Python/02.%E8%AF%AD%E8%A8%80%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="02-语言元素"><a href="#02-语言元素" class="headerlink" title="02 - 语言元素"></a>02 - 语言元素</h2><h4 id="指令和程序"><a href="#指令和程序" class="headerlink" title="指令和程序"></a>指令和程序</h4><p>计算机的硬件系统通常由五大部件构成，包括：运算器、控制器、存储器、输入设备和输出设备。其中，运算器和控制器放在一起就是我们通常所说的中央处理器，它的功能是执行各种运算和控制指令以及处理计算机软件中的数据。我们通常所说的程序实际上就是指令的集合，我们程序就是将一系列的指令按照某种方式组织到一起，然后通过这些指令去控制计算机做我们想让它做的事情。今天我们使用的计算机虽然器件做工越来越精密，处理能力越来越强大，但究其本质来说仍然属于<a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">“冯·诺依曼结构”</a>的计算机。“冯·诺依曼结构”有两个关键点，一是指出要将存储设备与中央处理器分开，二是提出了将数据以二进制方式编码。二进制是一种“逢二进一”的计数法，跟我们人类使用的“逢十进一”的计数法没有实质性的区别，人类因为有十根手指所以使用了十进制（因为在数数时十根手指用完之后就只能进位了，当然凡事都有例外，玛雅人可能是因为长年光着脚的原因把脚趾头也算上了，于是他们使用了二十进制的计数法，在这种计数法的指导下玛雅人的历法就与我们平常使用的历法不一样，而按照玛雅人的历法，2012年是上一个所谓的“太阳纪”的最后一年，而2013年则是新的“太阳纪”的开始，后来这件事情被以讹传讹的方式误传为”2012年是玛雅人预言的世界末日“这种荒诞的说法，今天我们可以大胆的猜测，玛雅文明之所以发展缓慢估计也与使用了二十进制有关）。对于计算机来说，二进制在物理器件上来说是最容易实现的（高电压表示1，低电压表示0），于是在“冯·诺依曼结构”的计算机都使用了二进制。虽然我们并不需要每个程序员都能够使用二进制的思维方式来工作，但是了解二进制以及它与我们生活中的十进制之间的转换关系，以及二进制与八进制和十六进制的转换关系还是有必要的。如果你对这一点不熟悉，可以自行使用<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6" target="_blank" rel="noopener">维基百科</a>或者<a href="https://baike.baidu.com" target="_blank" rel="noopener">百度百科</a>科普一下。</p>
<h3 id="变量和类型"><a href="#变量和类型" class="headerlink" title="变量和类型"></a>变量和类型</h3><p>在程序设计中，变量是一种存储数据的载体。计算机中的变量是实际存在的数据或者说是存储器中存储数据的一块内存空间，变量的值可以被读取和修改，这是所有计算和控制的基础。计算机能处理的数据有很多中类型，除了数值之外还可以处理文本、图形、音频、视频等各种各样的数据，那么不同的数据就需要定义不同的存储类型。Python中的数据类型很多，而且也允许我们自定义新的数据类型（这一点在后面会讲到），我们先介绍几种常用的数据类型。</p>
<ul>
<li>整型：Python中可以处理任意大小的整数（Python 2.x中有int和long两种类型的整数，但这种区分对Python来说意义不大，因此在Python 3.x中整数只有int这一种了），而且支持二进制（如<code>0b100</code>，换算成十进制是4）、八进制（如<code>0o100</code>，换算成十进制是64）、十进制（<code>100</code>）和十六进制（<code>0x100</code>，换算成十进制是256）的表示法。</li>
<li>浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如<code>123.456</code>）之外还支持科学计数法（如<code>1.23456e2</code>）。</li>
<li>字符串型：字符串是以单引号或双引号括起来的任意文本，比如<code>&#39;hello&#39;</code>和<code>&quot;hello&quot;</code>,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。</li>
<li>布尔型：布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来（例如<code>3 &lt; 5</code>会产生布尔值<code>True</code>，而<code>2 == 1</code>会产生布尔值<code>False</code>）。</li>
<li>复数型：形如<code>3+5j</code>，跟数学上的复数表示一样，唯一不同的是虚部的<code>i</code>换成了<code>j</code>。</li>
</ul>
<h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>对于每个变量我们需要给它取一个名字，就如同我们每个人都有属于自己的响亮的名字一样。在Python中，变量命名需要遵循以下这些必须遵守硬性规则和强烈建议遵守的非硬性规则。</p>
<ul>
<li>硬性规则：<ul>
<li>变量名由字母（广义的Unicode字符，不包括特殊字符）、数字和下划线构成，数字不能开头。</li>
<li>大小写敏感（大写的<code>a</code>和小写的<code>A</code>是两个不同的变量）。</li>
<li>不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突。</li>
</ul>
</li>
<li>PEP 8要求：<ul>
<li>用小写字母拼写，多个单词用下划线连接。</li>
<li>受保护的实例属性用单个下划线开头（后面会讲到）。</li>
<li>私有的实例属性用两个下划线开头（后面会讲到）。</li>
</ul>
</li>
</ul>
<p>当然，作为一个专业的程序员，给变量（事实上应该是所有的标识符）命名时做到见名知意也是非常重要的。</p>
<h4 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h4><p>下面通过几个例子来说明变量的类型和变量使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用变量保存数据并进行算术运算</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">321</span></span><br><span class="line">b = <span class="number">123</span></span><br><span class="line">print(a + b)</span><br><span class="line">print(a - b)</span><br><span class="line">print(a * b)</span><br><span class="line">print(a / b)</span><br><span class="line">print(a // b)</span><br><span class="line">print(a % b)</span><br><span class="line">print(a ** b)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用input函数输入</span></span><br><span class="line"><span class="string">使用int()进行类型转换</span></span><br><span class="line"><span class="string">用占位符格式化输出的字符串</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = int(input(<span class="string">'a = '</span>))</span><br><span class="line">b = int(input(<span class="string">'b = '</span>))</span><br><span class="line">print(<span class="string">'%d + %d = %d'</span> % (a, b, a + b))</span><br><span class="line">print(<span class="string">'%d - %d = %d'</span> % (a, b, a - b))</span><br><span class="line">print(<span class="string">'%d * %d = %d'</span> % (a, b, a * b))</span><br><span class="line">print(<span class="string">'%d / %d = %f'</span> % (a, b, a / b))</span><br><span class="line">print(<span class="string">'%d // %d = %d'</span> % (a, b, a // b))</span><br><span class="line">print(<span class="string">'%d %% %d = %d'</span> % (a, b, a % b))</span><br><span class="line">print(<span class="string">'%d ** %d = %d'</span> % (a, b, a ** b))</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用type()检查变量的类型</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">Date: 2018-02-27</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span></span><br><span class="line">b = <span class="number">12.345</span></span><br><span class="line">c = <span class="number">1</span> + <span class="number">5j</span></span><br><span class="line">d = <span class="string">'hello, world'</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(type(a))</span><br><span class="line">print(type(b))</span><br><span class="line">print(type(c))</span><br><span class="line">print(type(d))</span><br><span class="line">print(type(e))</span><br></pre></td></tr></table></figure>

<p>在对变量类型进行转换时可以使用Python的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。</p>
<ul>
<li>int()：将一个数值或字符串转换成整数，可以指定进制。</li>
<li>float()：将一个字符串转换成浮点数。</li>
<li>str()：将指定的对象转换成字符串形式，可以指定编码。</li>
<li>chr()：将整数转换成该编码对应的字符串（一个字符）。</li>
<li>ord()：将字符串（一个字符）转换成对应的编码（整数）。</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>Python支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>[]</code> <code>[:]</code></td>
<td>下标，切片</td>
</tr>
<tr>
<td><code>**</code></td>
<td>指数</td>
</tr>
<tr>
<td><code>~</code> <code>+</code> <code>-</code></td>
<td>按位取反, 正负号</td>
</tr>
<tr>
<td><code>*</code> <code>/</code> <code>%</code> <code>//</code></td>
<td>乘，除，模，整除</td>
</tr>
<tr>
<td><code>+</code> <code>-</code></td>
<td>加，减</td>
</tr>
<tr>
<td><code>&gt;&gt;</code> <code>&lt;&lt;</code></td>
<td>右移，左移</td>
</tr>
<tr>
<td><code>&amp;</code></td>
<td>按位与</td>
</tr>
<tr>
<td><code>^</code> `</td>
<td>`</td>
</tr>
<tr>
<td><code>&lt;=</code> <code>&lt;</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>小于等于，小于，大于，大于等于</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>等于，不等于</td>
</tr>
<tr>
<td><code>is</code>  <code>is not</code></td>
<td>身份运算符</td>
</tr>
<tr>
<td><code>in</code> <code>not in</code></td>
<td>成员运算符</td>
</tr>
<tr>
<td><code>not</code> <code>or</code> <code>and</code></td>
<td>逻辑运算符</td>
</tr>
<tr>
<td><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>//=</code> <code>**=</code> <code>&amp;=</code> `</td>
<td>=<code></code>^=<code></code>&gt;&gt;=<code></code>&lt;&lt;=`</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong>在实际开发中，如果搞不清楚优先级可以使用括号来确保运算的执行顺序。</p>
</blockquote>
<p>下面的例子演示了运算符的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">运算符的使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">5</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line">d = <span class="number">4</span></span><br><span class="line">e = <span class="number">5</span></span><br><span class="line">a += b</span><br><span class="line">a -= c</span><br><span class="line">a *= d</span><br><span class="line">a /= e</span><br><span class="line">print(<span class="string">"a = "</span>, a)</span><br><span class="line"></span><br><span class="line">flag1 = <span class="number">3</span> &gt; <span class="number">2</span></span><br><span class="line">flag2 = <span class="number">2</span> &lt; <span class="number">1</span></span><br><span class="line">flag3 = flag1 <span class="keyword">and</span> flag2</span><br><span class="line">flag4 = flag1 <span class="keyword">or</span> flag2</span><br><span class="line">flag5 = <span class="keyword">not</span> flag1</span><br><span class="line">print(<span class="string">"flag1 = "</span>, flag1)</span><br><span class="line">print(<span class="string">"flag2 = "</span>, flag2)</span><br><span class="line">print(<span class="string">"flag3 = "</span>, flag3)</span><br><span class="line">print(<span class="string">"flag4 = "</span>, flag4)</span><br><span class="line">print(<span class="string">"flag5 = "</span>, flag5)</span><br><span class="line">print(flag1 <span class="keyword">is</span> <span class="literal">True</span>)</span><br><span class="line">print(flag2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：华氏温度转摄氏温度。"><a href="#练习1：华氏温度转摄氏温度。" class="headerlink" title="练习1：华氏温度转摄氏温度。"></a>练习1：华氏温度转摄氏温度。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">将华氏温度转换为摄氏温度</span></span><br><span class="line"><span class="string">F = 1.8C + 32</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">f = float(input(<span class="string">'请输入华氏温度: '</span>))</span><br><span class="line">c = (f - <span class="number">32</span>) / <span class="number">1.8</span></span><br><span class="line">print(<span class="string">'%.1f华氏度 = %.1f摄氏度'</span> % (f, c))</span><br></pre></td></tr></table></figure>

<h4 id="练习2：输入圆的半径计算计算周长和面积。"><a href="#练习2：输入圆的半径计算计算周长和面积。" class="headerlink" title="练习2：输入圆的半径计算计算周长和面积。"></a>练习2：输入圆的半径计算计算周长和面积。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入半径计算圆的周长和面积</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line">radius = float(input(<span class="string">'请输入圆的半径: '</span>))</span><br><span class="line">perimeter = <span class="number">2</span> * math.pi * radius</span><br><span class="line">area = math.pi * radius * radius</span><br><span class="line">print(<span class="string">'周长: %.2f'</span> % perimeter)</span><br><span class="line">print(<span class="string">'面积: %.2f'</span> % area)</span><br></pre></td></tr></table></figure>

<h4 id="练习3：输入年份判断是不是闰年。"><a href="#练习3：输入年份判断是不是闰年。" class="headerlink" title="练习3：输入年份判断是不是闰年。"></a>练习3：输入年份判断是不是闰年。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入年份 如果是闰年输出True 否则输出False</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Version: 0.1</span></span><br><span class="line"><span class="string">Author: 骆昊</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">year = int(input(<span class="string">'请输入年份: '</span>))</span><br><span class="line"><span class="comment"># 如果代码太长写成一行不便于阅读 可以使用\或()折行</span></span><br><span class="line">is_leap = (year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span></span><br><span class="line">           year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">print(is_leap)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>06-函数和模块的使用</title>
    <url>/2019/10/02/tutorials/Python/06.%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="06-函数和模块的使用"><a href="#06-函数和模块的使用" class="headerlink" title="06-函数和模块的使用"></a>06-函数和模块的使用</h2><p>在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。</p>
<p>$$x_1 + x_2 + x_3 + x_4 = 8$$</p>
<p>事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。</p>
<p>$$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$</p>
<p>可以用Python的程序来计算出这个值，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入M和N计算C(M,N)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">m = int(input(<span class="string">'m = '</span>))</span><br><span class="line">n = int(input(<span class="string">'n = '</span>))</span><br><span class="line">fm = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    fm *= num</span><br><span class="line">fn = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    fn *= num</span><br><span class="line">fmn = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, m - n + <span class="number">1</span>):</span><br><span class="line">    fmn *= num</span><br><span class="line">print(fm // fn // fmn)</span><br></pre></td></tr></table></figure>

<h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><p>不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。</p>
<h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过<code>return</code>关键字来返回一个值，这相当于数学上说的函数的因变量。</p>
<p>在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求阶乘</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param num: 非负整数</span></span><br><span class="line"><span class="string">    :return: num的阶乘</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= n</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = int(input(<span class="string">'m = '</span>))</span><br><span class="line">n = int(input(<span class="string">'n = '</span>))</span><br><span class="line"><span class="comment"># 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span></span><br><span class="line">print(factorial(m) // factorial(n) // factorial(m - n))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明：</strong>Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。</p>
</blockquote>
<h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" target="_blank" rel="noopener">函数的重载</a>，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roll_dice</span><span class="params">(n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    摇色子</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param n: 色子的个数</span></span><br><span class="line"><span class="string">    :return: n颗色子点数之和</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        total += randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有指定参数那么使用默认值摇两颗色子</span></span><br><span class="line">print(roll_dice())</span><br><span class="line"><span class="comment"># 摇三颗色子</span></span><br><span class="line">print(roll_dice(<span class="number">3</span>))</span><br><span class="line">print(add())</span><br><span class="line">print(add(<span class="number">1</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 传递参数时可以不按照设定的顺序进行传递</span></span><br><span class="line">print(add(c=<span class="number">50</span>, a=<span class="number">100</span>, b=<span class="number">200</span>))</span><br></pre></td></tr></table></figure>

<p>我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用<code>add</code>函数，这跟其他很多语言中函数重载的效果是一致的。</p>
<p>其实上面的<code>add</code>函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在参数名前面的*表示args是一个可变参数</span></span><br><span class="line"><span class="comment"># 即在调用add函数时可以传入0个或多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(*args)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add())</span><br><span class="line">print(add(<span class="number">1</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure>

<h3 id="用模块管理函数"><a href="#用模块管理函数" class="headerlink" title="用模块管理函数"></a>用模块管理函数</h3><p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码会输出什么呢？</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为<code>foo</code>的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的<code>foo</code>函数，代码如下所示。</p>
<p>module1.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)</span><br></pre></td></tr></table></figure>

<p>module2.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br></pre></td></tr></table></figure>

<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出hello, world!</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出goodbye, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p>
<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module1 <span class="keyword">as</span> m1</span><br><span class="line"><span class="keyword">import</span> module2 <span class="keyword">as</span> m2</span><br><span class="line"></span><br><span class="line">m1.foo()</span><br><span class="line">m2.foo()</span><br></pre></td></tr></table></figure>

<p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个<code>foo</code>，因为后导入的foo覆盖了之前导入的<code>foo</code>。</p>
<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出goodbye, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出hello, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。</p>
<p>module3.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span></span><br><span class="line"><span class="comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'call foo()'</span>)</span><br><span class="line">    foo()</span><br><span class="line">    print(<span class="string">'call bar()'</span>)</span><br><span class="line">    bar()</span><br></pre></td></tr></table></figure>

<p>test.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> module3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：实现计算求最大公约数和最小公倍数的函数。"><a href="#练习1：实现计算求最大公约数和最小公倍数的函数。" class="headerlink" title="练习1：实现计算求最大公约数和最小公倍数的函数。"></a>练习1：实现计算求最大公约数和最小公倍数的函数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    (x, y) = (y, x) <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> (x, y)</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> x % factor == <span class="number">0</span> <span class="keyword">and</span> y % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> factor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y // gcd(x, y)</span><br></pre></td></tr></table></figure>

<h4 id="练习2：实现判断一个数是不是回文数的函数。"><a href="#练习2：实现判断一个数是不是回文数的函数。" class="headerlink" title="练习2：实现判断一个数是不是回文数的函数。"></a>练习2：实现判断一个数是不是回文数的函数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(num)</span>:</span></span><br><span class="line">    temp = num</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">        total = total * <span class="number">10</span> + temp % <span class="number">10</span></span><br><span class="line">        temp //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> total == num</span><br></pre></td></tr></table></figure>

<h4 id="练习3：实现判断一个数是不是素数的函数。"><a href="#练习3：实现判断一个数是不是素数的函数。" class="headerlink" title="练习3：实现判断一个数是不是素数的函数。"></a>练习3：实现判断一个数是不是素数的函数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> range(<span class="number">2</span>, num):</span><br><span class="line">        <span class="keyword">if</span> num % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> num != <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="练习4：写一个程序判断输入的正整数是不是回文素数。"><a href="#练习4：写一个程序判断输入的正整数是不是回文素数。" class="headerlink" title="练习4：写一个程序判断输入的正整数是不是回文素数。"></a>练习4：写一个程序判断输入的正整数是不是回文素数。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入正整数: '</span>))</span><br><span class="line">    <span class="keyword">if</span> is_palindrome(num) <span class="keyword">and</span> is_prime(num):</span><br><span class="line">        print(<span class="string">'%d是回文素数'</span> % num)</span><br></pre></td></tr></table></figure>

<p>通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。</p>
<p>最后，我们来讨论一下Python中有关变量作用域的问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>  <span class="comment"># Python中可以在函数内部再定义函数</span></span><br><span class="line">        c = <span class="literal">True</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">        print(c)</span><br><span class="line"></span><br><span class="line">    bar()</span><br><span class="line">    <span class="comment"># print(c)  # NameError: name 'c' is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="comment"># print(b)  # NameError: name 'b' is not defined</span></span><br><span class="line">    foo()</span><br></pre></td></tr></table></figure>

<p>上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在<code>bar</code>函数的内部并没有定义<code>a</code>和<code>b</code>两个变量，那么<code>a</code>和<code>b</code>是从哪里来的。我们在上面代码的<code>if</code>分支中定义了一个变量<code>a</code>，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的<code>foo</code>函数中我们定义了变量<code>b</code>，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在<code>foo</code>函数的外部并不能访问到它；但对于<code>foo</code>函数内部的<code>bar</code>函数来说，变量<code>b</code>属于嵌套作用域，在<code>bar</code>函数中我们是可以访问到它的。<code>bar</code>函数中的变量<code>c</code>属于局部作用域，在<code>bar</code>函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符<code>min</code>、<code>len</code>等都属于内置作用域）。</p>
<p>再看看下面这段代码，我们希望通过函数调用修改全局变量<code>a</code>的值，但实际上下面的代码是做不到的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    foo()</span><br><span class="line">    print(a)  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<p>在调用<code>foo</code>函数后，我们发现<code>a</code>的值仍然是100，这是因为当我们在函数<code>foo</code>中写<code>a = 200</code>的时候，是重新定义了一个名字为<code>a</code>的局部变量，它跟全局作用域的<code>a</code>并不是同一个变量，因为局部作用域中有了自己的变量<code>a</code>，因此<code>foo</code>函数不再搜索全局作用域中的<code>a</code>。如果我们希望在<code>foo</code>函数中修改全局作用域中的<code>a</code>，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    foo()</span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br></pre></td></tr></table></figure>

<p>我们可以使用<code>global</code>关键字来指示<code>foo</code>函数中的变量<code>a</code>来自于全局作用域，如果全局作用域中没有<code>a</code>，那么下面一行的代码就会定义变量<code>a</code>并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用<code>nonlocal</code>关键字来指示变量来自于嵌套作用域，请大家自行试验。</p>
<p>在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">垃圾回收</a>。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对<a href="https://zh.wikipedia.org/zh-hans/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">迪米特法则</a>的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">闭包</a>，这个我们在后续的内容中进行讲解。</p>
<blockquote>
<p><strong>说明</strong>：很多人经常会将“闭包”一词和<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">“匿名函数”</a>混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">维基百科</a>或者<a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>上对这个概念的讨论。</p>
</blockquote>
<p>说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Todo: Add your code here</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>08-面向对象编程基础</title>
    <url>/2019/10/02/tutorials/Python/08.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h2 id="08-面向对象编程基础"><a href="#08-面向对象编程基础" class="headerlink" title="08-面向对象编程基础"></a>08-面向对象编程基础</h2><p>活在当下的程序员应该都听过“面向对象编程”一词，也经常有人问能不能用一句话解释下什么是“面向对象编程”，我们先来看看比较正式的说法。</p>
<blockquote>
<p>把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。</p>
</blockquote>
<p>这样一说是不是更不明白了。所以我们还是看看更通俗易懂的说法，下面这段内容来自于<a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>。</p>
<p><img src="./res/oop-zhihu.png" alt=""></p>
<a id="more"></a>
<blockquote>
<p><strong>说明</strong>：以上的内容来自于网络，不代表作者本人的观点和看法，与作者本人立场无关，相关责任不由作者承担。</p>
</blockquote>
<p>之前我们说过“程序是指令的集合”，我们在程序中书写的语句在执行时会变成一条或多条指令然后由CPU去执行。当然为了简化程序的设计，我们引入了函数的概念，把相对独立且经常重复使用的代码放置到函数中，在需要使用这些功能的时候只要调用函数即可；如果一个函数的功能过于复杂和臃肿，我们又可以进一步将函数继续切分为子函数来降低系统的复杂性。但是说了这么多，不知道大家是否发现，所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。但是，计算机的工作方式与正常人类的思维模式是不同的，如果编程就必须得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多，“每个人都应该学习编程”这样的豪言壮语就只能说说而已。当然，这些还不是最重要的，最重要的是当我们需要开发一个复杂的系统时，代码的复杂性会让开发和维护工作都变得举步维艰，所以在上世纪60年代末期，“<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA" target="_blank" rel="noopener">软件危机</a>”、“<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B" target="_blank" rel="noopener">软件工程</a>”等一系列的概念开始在行业中出现。</p>
<p>当然，程序员圈子内的人都知道，现实中并没有解决上面所说的这些问题的“<a href="https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9" target="_blank" rel="noopener">银弹</a>”，真正让软件开发者看到希望的是上世纪70年代诞生的<a href="https://zh.wikipedia.org/wiki/Smalltalk" target="_blank" rel="noopener">Smalltalk</a>编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的<a href="https://zh.wikipedia.org/wiki/Simula" target="_blank" rel="noopener">Simula</a>语言）。按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，我们称之为“对象”，而我们解决问题的方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以让我们构造出复杂的系统来解决现实中的问题。</p>
<blockquote>
<p><strong>说明</strong>：当然面向对象也不是解决软件开发中所有问题的最后的“银弹”，所以今天的高级程序设计语言几乎都提供了对多种编程范式的支持，Python也不例外。</p>
</blockquote>
<h3 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h3><p>简单的说，类是对象的蓝图和模板，而对象是类的实例。这个解释虽然有点像用概念在解释概念，但是从这句话我们至少可以看出，类是抽象的概念，而对象是具体的东西。在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。当我们把一大堆拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。</p>
<p><img src="./res/object-feature.png" alt=""></p>
<h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>在Python中可以使用<code>class</code>关键字定义类，然后在类中通过之前学习过的函数来定义方法，这样就可以将对象的动态特征描述出来，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># __init__是一个特殊方法用于在创建对象时进行初始化操作</span></span><br><span class="line">    <span class="comment"># 通过这个方法我们可以为学生对象绑定name和age两个属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self, course_name)</span>:</span></span><br><span class="line">        print(<span class="string">'%s正在学习%s.'</span> % (self.name, course_name))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># PEP 8要求标识符的名字用全小写多个单词用下划线连接</span></span><br><span class="line">    <span class="comment"># 但是很多程序员和公司更倾向于使用驼峰命名法(驼峰标识)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_av</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.age &lt; <span class="number">18</span>:</span><br><span class="line">            print(<span class="string">'%s只能观看《熊出没》.'</span> % self.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在观看岛国爱情动作片.'</span> % self.name</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：写在类中的函数，我们通常称之为（对象的）方法，这些方法就是对象可以接收的消息。</p>
</blockquote>
<h3 id="创建和使用对象"><a href="#创建和使用对象" class="headerlink" title="创建和使用对象"></a>创建和使用对象</h3><p>当我们定义好一个类之后，可以通过下面的方式来创建对象并给对象发消息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建学生对象并指定姓名和年龄</span></span><br><span class="line">    stu1 = Student(<span class="string">'骆昊'</span>, <span class="number">38</span>)</span><br><span class="line">    <span class="comment"># 给对象发study消息</span></span><br><span class="line">    stu1.study(<span class="string">'Python程序设计'</span>)</span><br><span class="line">    <span class="comment"># 给对象发watch_av消息</span></span><br><span class="line">    stu1.watch_av()</span><br><span class="line">    stu2 = Student(<span class="string">'王大锤'</span>, <span class="number">15</span>)</span><br><span class="line">    stu2.study(<span class="string">'思想品德'</span>)</span><br><span class="line">    stu2.watch_av()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="访问可见性问题"><a href="#访问可见性问题" class="headerlink" title="访问可见性问题"></a>访问可见性问题</h3><p>对于上面的代码，有C++、Java、C#等编程经验的程序员可能会问，我们给<code>Student</code>对象绑定的<code>name</code>和<code>age</code>属性到底具有怎样的访问权限（也称为可见性）。因为在很多面向对象编程语言中，我们通常会将对象的属性设置为私有的（private）或受保护的（protected），简单的说就是不允许外界访问，而对象的方法通常都是公开的（public），因为公开的方法就是对象能够接受的消息。在Python中，属性和方法的访问权限只有两种，也就是公开的和私有的，如果希望属性是私有的，在给属性命名时可以用两个下划线作为开头，下面的代码可以验证这一点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, foo)</span>:</span></span><br><span class="line">        self.__foo = foo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__foo)</span><br><span class="line">        print(<span class="string">'__bar'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    test = Test(<span class="string">'hello'</span>)</span><br><span class="line">    <span class="comment"># AttributeError: 'Test' object has no attribute '__bar'</span></span><br><span class="line">    test.__bar()</span><br><span class="line">    <span class="comment"># AttributeError: 'Test' object has no attribute '__foo'</span></span><br><span class="line">    print(test.__foo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>但是，Python并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来“妨碍”对它们的访问，事实上如果你知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。之所以这样设定，可以用这样一句名言加以解释，就是“We are all consenting adults here”。因为绝大多数程序员都认为开放比封闭要好，而且程序员要自己为自己的行为负责。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, foo)</span>:</span></span><br><span class="line">        self.__foo = foo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.__foo)</span><br><span class="line">        print(<span class="string">'__bar'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    test = Test(<span class="string">'hello'</span>)</span><br><span class="line">    test._Test__bar()</span><br><span class="line">    print(test._Test__foo)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数Python程序员会遵循一种命名惯例就是让属性名以单下划线开头来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻，关于这一点可以看看我的<a href="http://blog.csdn.net/jackfrued/article/details/79521404" target="_blank" rel="noopener">《Python - 那些年我们踩过的那些坑》</a>文章中的讲解。</p>
<h3 id="面向对象的支柱"><a href="#面向对象的支柱" class="headerlink" title="面向对象的支柱"></a>面向对象的支柱</h3><p>面向对象有三大支柱：封装、继承和多态。后面两个概念在下一个章节中进行详细的说明，这里我们先说一下什么是封装。我自己对封装的理解是“隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口”。我们在类中定义的方法其实就是把数据和对数据的操作封装起来了，在我们创建了对象之后，只需要给对象发送一个消息（调用方法）就可以执行方法中的代码，也就是说我们只需要知道方法的名字和传入的参数（方法的外部视图），而不需要知道方法内部的实现细节（方法的内部视图）。</p>
<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：定义一个类描述数字时钟"><a href="#练习1：定义一个类描述数字时钟" class="headerlink" title="练习1：定义一个类描述数字时钟"></a>练习1：定义一个类描述数字时钟</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""数字时钟"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param hour: 时</span></span><br><span class="line"><span class="string">        :param minute: 分</span></span><br><span class="line"><span class="string">        :param second: 秒</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._hour = hour</span><br><span class="line">        self._minute = minute</span><br><span class="line">        self._second = second</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""走字"""</span></span><br><span class="line">        self._second += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._second == <span class="number">60</span>:</span><br><span class="line">            self._second = <span class="number">0</span></span><br><span class="line">            self._minute += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._minute == <span class="number">60</span>:</span><br><span class="line">                self._minute = <span class="number">0</span></span><br><span class="line">                self._hour += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self._hour == <span class="number">24</span>:</span><br><span class="line">                    self._hour = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示时间"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%02d:%02d:%02d'</span> % \</span><br><span class="line">               (self._hour, self._minute, self._second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    clock = Clock(<span class="number">23</span>, <span class="number">59</span>, <span class="number">58</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(clock.show())</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        clock.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。"><a href="#练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。" class="headerlink" title="练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。"></a>练习2：定义一个类描述平面上的点并提供移动点和计算到另一个点距离的方法。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>, y=<span class="number">0</span>)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param x: 横坐标</span></span><br><span class="line"><span class="string">        :param y: 纵坐标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_to</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="string">"""移动到指定位置</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param x: 新的横坐标</span></span><br><span class="line"><span class="string">        "param y: 新的纵坐标</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">move_by</span><span class="params">(self, dx, dy)</span>:</span></span><br><span class="line">        <span class="string">"""移动指定的增量</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param dx: 横坐标的增量</span></span><br><span class="line"><span class="string">        "param dy: 纵坐标的增量</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.x += dx</span><br><span class="line">        self.y += dy</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">distance_to</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""计算与另一个点的距离</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :param other: 另一个点</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        dx = self.x - other.x</span><br><span class="line">        dy = self.y - other.y</span><br><span class="line">        <span class="keyword">return</span> sqrt(dx ** <span class="number">2</span> + dy ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'(%s, %s)'</span> % (str(self.x), str(self.y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p1 = Point(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">    p2 = Point()</span><br><span class="line">    print(p1)</span><br><span class="line">    print(p2)</span><br><span class="line">    p2.move_by(<span class="number">-1</span>, <span class="number">2</span>)</span><br><span class="line">    print(p2)</span><br><span class="line">    print(p1.distance_to(p2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：本章中的插图来自于Grady Booch等著作的<a href="https://item.jd.com/20476561918.html" target="_blank" rel="noopener">《面向对象分析与设计》</a>一书，该书是讲解面向对象编程的经典著作，有兴趣的读者可以购买和阅读这本书来了解更多的面向对象的相关知识。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>11-使用正则表达式</title>
    <url>/2019/10/02/tutorials/Python/11.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="11-使用正则表达式"><a href="#11-使用正则表达式" class="headerlink" title="11-使用正则表达式"></a>11-使用正则表达式</h2><h3 id="正则表达式相关知识"><a href="#正则表达式相关知识" class="headerlink" title="正则表达式相关知识"></a>正则表达式相关知识</h3><p>在编写处理字符串的程序或网页时，经常会有查找符合某些复杂规则的字符串的需要，正则表达式就是用于描述这些规则的工具，换句话说正则表达式是一种工具，它定义了字符串的匹配模式（如何检查一个字符串是否有跟某种模式匹配的部分或者从一个字符串中将与模式匹配的部分提取出来或者替换掉）。如果你在Windows操作系统中使用过文件查找并且在指定文件名时使用过通配符（*和?），那么正则表达式也是与之类似的用来进行文本匹配的工具，只不过比起通配符正则表达式更强大，它能更精确地描述你的需求（当然你付出的代价是书写一个正则表达式比打出一个通配符要复杂得多，要知道任何给你带来好处的东西都是有代价的，就如同学习一门编程语言一样），比如你可以编写一个正则表达式，用来查找所有以0开头，后面跟着2-3个数字，然后是一个连字号“-”，最后是7或8位数字的字符串（像028-12345678或0813-7654321），这不就是国内的座机号码吗。最初计算机是为了做数学运算而诞生的，处理的信息基本上都是数值，而今天我们在日常工作中处理的信息基本上都是文本数据，我们希望计算机能够识别和处理符合某些模式的文本，正则表达式就显得非常重要了。今天几乎所有的编程语言都提供了对正则表达式操作的支持，Python通过标准库中的re模块来支持正则表达式操作。</p>
<p>我们可以考虑下面一个问题：我们从某个地方（可能是一个文本文件，也可能是网络上的一则新闻）获得了一个字符串，希望在字符串中找出手机号和座机号。当然我们可以设定手机号是11位的数字（注意并不是随机的11位数字，因为你没有见过“25012345678”这样的手机号吧）而座机号跟上一段中描述的模式相同，如果不使用正则表达式要完成这个任务就会很麻烦。</p>
<p>关于正则表达式的相关知识，大家可以阅读一篇非常有名的博客叫<a href="https://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">《正则表达式30分钟入门教程》</a>，读完这篇文章后你就可以看懂下面的表格，这是我们对正则表达式中的一些基本符号进行的扼要总结。</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>解释</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td>匹配任意字符</td>
<td>b.t</td>
<td>可以匹配bat / but / b#t / b1t等</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母/数字/下划线</td>
<td>b\wt</td>
<td>可以匹配bat / b1t / b_t等<br>但不能匹配b#t</td>
</tr>
<tr>
<td>\s</td>
<td>匹配空白字符（包括\r、\n、\t等）</td>
<td>love\syou</td>
<td>可以匹配love you</td>
</tr>
<tr>
<td>\d</td>
<td>匹配数字</td>
<td>\d\d</td>
<td>可以匹配01 / 23 / 99等</td>
</tr>
<tr>
<td>\b</td>
<td>匹配单词的边界</td>
<td>\bThe\b</td>
<td></td>
</tr>
<tr>
<td>^</td>
<td>匹配字符串的开始</td>
<td>^The</td>
<td>可以匹配The开头的字符串</td>
</tr>
<tr>
<td>$</td>
<td>匹配字符串的结束</td>
<td>.exe$</td>
<td>可以匹配.exe结尾的字符串</td>
</tr>
<tr>
<td>\W</td>
<td>匹配非字母/数字/下划线</td>
<td>b\Wt</td>
<td>可以匹配b#t / b@t等<br>但不能匹配but / b1t / b_t等</td>
</tr>
<tr>
<td>\S</td>
<td>匹配非空白字符</td>
<td>love\Syou</td>
<td>可以匹配love#you等<br>但不能匹配love you</td>
</tr>
<tr>
<td>\D</td>
<td>匹配非数字</td>
<td>\d\D</td>
<td>可以匹配9a / 3# / 0F等</td>
</tr>
<tr>
<td>\B</td>
<td>匹配非单词边界</td>
<td>\Bio\B</td>
<td></td>
</tr>
<tr>
<td>[]</td>
<td>匹配来自字符集的任意单一字符</td>
<td>[aeiou]</td>
<td>可以匹配任一元音字母字符</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在字符集中的任意单一字符</td>
<td>[^aeiou]</td>
<td>可以匹配任一非元音字母字符</td>
</tr>
<tr>
<td>*</td>
<td>匹配0次或多次</td>
<td>\w*</td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>匹配1次或多次</td>
<td>\w+</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>匹配0次或1次</td>
<td>\w?</td>
<td></td>
</tr>
<tr>
<td>{N}</td>
<td>匹配N次</td>
<td>\w{3}</td>
<td></td>
</tr>
<tr>
<td>{M,}</td>
<td>匹配至少M次</td>
<td>\w{3,}</td>
<td></td>
</tr>
<tr>
<td>{M,N}</td>
<td>匹配至少M次至多N次</td>
<td>\w{3,6}</td>
<td></td>
</tr>
<tr>
<td>|</td>
<td>分支</td>
<td>foo|bar</td>
<td>可以匹配foo或者bar</td>
</tr>
<tr>
<td>(?#)</td>
<td>注释</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(exp)</td>
<td>匹配exp并捕获到自动命名的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;name&gt;exp)</td>
<td>匹配exp并捕获到名为name的组中</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?:exp)</td>
<td>匹配exp但是不捕获匹配的文本</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?=exp)</td>
<td>匹配exp前面的位置</td>
<td>\b\w+(?=ing)</td>
<td>可以匹配I’m dancing中的danc</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>匹配exp后面的位置</td>
<td>(?&lt;=\bdanc)\w+\b</td>
<td>可以匹配I love dancing and reading中的第一个ing</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>匹配后面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>匹配前面不是exp的位置</td>
<td></td>
<td></td>
</tr>
<tr>
<td>*?</td>
<td>重复任意次，但尽可能少重复</td>
<td>a.*b<br>a.*?b</td>
<td>将正则表达式应用于aabab，前者会匹配整个字符串aabab，后者会匹配aab和ab两个字符串</td>
</tr>
<tr>
<td>+?</td>
<td>重复1次或多次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>??</td>
<td>重复0次或1次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,N}?</td>
<td>重复M到N次，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
<tr>
<td>{M,}?</td>
<td>重复M次以上，但尽可能少重复</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong>如果需要匹配的字符是正则表达式中的特殊字符，那么可以使用\进行转义处理，例如想匹配小数点可以写成\.就可以了，因为直接写.会匹配任意字符；同理，想匹配圆括号必须写成\(和\)，否则圆括号被视为正则表达式中的分组。</p>
</blockquote>
<h3 id="Python对正则表达式的支持"><a href="#Python对正则表达式的支持" class="headerlink" title="Python对正则表达式的支持"></a>Python对正则表达式的支持</h3><p>Python提供了re模块来支持正则表达式相关操作，下面是re模块中的核心函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>compile(pattern, flags=0)</td>
<td>编译正则表达式返回正则表达式对象</td>
</tr>
<tr>
<td>match(pattern, string, flags=0)</td>
<td>用正则表达式匹配字符串 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>search(pattern, string, flags=0)</td>
<td>搜索字符串中第一次出现正则表达式的模式 成功返回匹配对象 否则返回None</td>
</tr>
<tr>
<td>split(pattern, string, maxsplit=0, flags=0)</td>
<td>用正则表达式指定的模式分隔符拆分字符串 返回列表</td>
</tr>
<tr>
<td>sub(pattern, repl, string, count=0, flags=0)</td>
<td>用指定的字符串替换原字符串中与正则表达式匹配的模式 可以用count指定替换的次数</td>
</tr>
<tr>
<td>fullmatch(pattern, string, flags=0)</td>
<td>match函数的完全匹配（从字符串开头到结尾）版本</td>
</tr>
<tr>
<td>findall(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回字符串的列表</td>
</tr>
<tr>
<td>finditer(pattern, string, flags=0)</td>
<td>查找字符串所有与正则表达式匹配的模式 返回一个迭代器</td>
</tr>
<tr>
<td>purge()</td>
<td>清除隐式编译的正则表达式的缓存</td>
</tr>
<tr>
<td>re.I / re.IGNORECASE</td>
<td>忽略大小写匹配标记</td>
</tr>
<tr>
<td>re.M / re.MULTILINE</td>
<td>多行匹配标记</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>说明：</strong>上面提到的re模块中的这些函数，实际开发中也可以用正则表达式对象的方法替代对这些函数的使用，如果一个正则表达式需要重复的使用，那么先通过compile函数编译正则表达式并创建出正则表达式对象无疑是更为明智的选择。</p>
</blockquote>
<p>下面我们通过一系列的例子来告诉大家在Python中如何使用正则表达式。</p>
<h4 id="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"><a href="#例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。" class="headerlink" title="例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。"></a>例子1：验证输入用户名和QQ号是否有效并给出对应的提示信息。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">验证输入用户名和QQ号是否有效并给出对应的提示信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">要求：用户名必须由字母、数字或下划线构成且长度在6~20个字符之间，QQ号是5~12的数字且首位不能为0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    username = input(<span class="string">'请输入用户名: '</span>)</span><br><span class="line">    qq = input(<span class="string">'请输入QQ号: '</span>)</span><br><span class="line">    <span class="comment"># match函数的第一个参数是正则表达式字符串或正则表达式对象</span></span><br><span class="line">    <span class="comment"># 第二个参数是要跟正则表达式做匹配的字符串对象</span></span><br><span class="line">    m1 = re.match(<span class="string">r'^[0-9a-zA-Z_]&#123;6,20&#125;$'</span>, username)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m1:</span><br><span class="line">        print(<span class="string">'请输入有效的用户名.'</span>)</span><br><span class="line">    m2 = re.match(<span class="string">r'^[1-9]\d&#123;4,11&#125;$'</span>, qq)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> m2:</span><br><span class="line">        print(<span class="string">'请输入有效的QQ号.'</span>)</span><br><span class="line">    <span class="keyword">if</span> m1 <span class="keyword">and</span> m2:</span><br><span class="line">        print(<span class="string">'你输入的信息是有效的!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>提示</strong>：上面在书写正则表达式时使用了“原始字符串”的写法（在字符串前面加上了r），所谓“原始字符串”就是字符串中的每个字符都是它原始的意义，说得更直接一点就是字符串中没有所谓的转义字符啦。因为正则表达式中有很多元字符和需要进行转义的地方，如果不使用原始字符串就需要将反斜杠写作\\，例如表示数字的\d得书写成\\d，这样不仅写起来不方便，阅读的时候也会很吃力。</p>
</blockquote>
<h4 id="例子2：从一段文字中提取出国内手机号码。"><a href="#例子2：从一段文字中提取出国内手机号码。" class="headerlink" title="例子2：从一段文字中提取出国内手机号码。"></a>例子2：从一段文字中提取出国内手机号码。</h4><p>下面这张图是截止到2017年底，国内三家运营商推出的手机号段。</p>
<p><img src="./res/tel-start-number.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建正则表达式对象 使用了前瞻和回顾来保证手机号前后不应该出现数字</span></span><br><span class="line">    pattern = re.compile(<span class="string">r'(?&lt;=\D)1[34578]\d&#123;9&#125;(?=\D)'</span>)</span><br><span class="line">    sentence = <span class="string">'''</span></span><br><span class="line"><span class="string">    重要的事情说8130123456789遍，我的手机号是13512346789这个靓号，</span></span><br><span class="line"><span class="string">    不是15600998765，也是110或119，王大锤的手机号才是15600998765。</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 查找所有匹配并保存到一个列表中</span></span><br><span class="line">    mylist = re.findall(pattern, sentence)</span><br><span class="line">    print(mylist)</span><br><span class="line">    print(<span class="string">'--------华丽的分隔线--------'</span>)</span><br><span class="line">    <span class="comment"># 通过迭代器取出匹配对象并获得匹配的内容</span></span><br><span class="line">    <span class="keyword">for</span> temp <span class="keyword">in</span> pattern.finditer(sentence):</span><br><span class="line">        print(temp.group())</span><br><span class="line">    print(<span class="string">'--------华丽的分隔线--------'</span>)</span><br><span class="line">    <span class="comment"># 通过search函数指定搜索位置找出所有匹配</span></span><br><span class="line">    m = pattern.search(sentence)</span><br><span class="line">    <span class="keyword">while</span> m:</span><br><span class="line">        print(m.group())</span><br><span class="line">        m = pattern.search(sentence, m.end())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：上面匹配国内手机号的正则表达式并不够好，因为像14开头的号码只有145或147，而上面的正则表达式并没有考虑这种情况，要匹配国内手机号，更好的正则表达式的写法是：<code>(?&lt;=\D)(1[38]\d{9}|14[57]\d{8}|15[0-35-9]\d{8}|17[678]\d{8})(?=\D)</code>，国内最近好像有19和16开头的手机号了，但是这个暂时不在我们考虑之列。</p>
</blockquote>
<h4 id="例子3：替换字符串中的不良内容"><a href="#例子3：替换字符串中的不良内容" class="headerlink" title="例子3：替换字符串中的不良内容"></a>例子3：替换字符串中的不良内容</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    sentence = <span class="string">'你丫是傻叉吗? 我操你大爷的. Fuck you.'</span></span><br><span class="line">    purified = re.sub(<span class="string">'[操肏艹]|fuck|shit|傻[比屄逼叉缺吊屌]|煞笔'</span>,</span><br><span class="line">                      <span class="string">'*'</span>, sentence, flags=re.IGNORECASE)</span><br><span class="line">    print(purified)  <span class="comment"># 你丫是*吗? 我*你大爷的. * you.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：re模块的正则表达式相关函数中都有一个flags参数，它代表了正则表达式的匹配标记，可以通过该标记来指定匹配时是否忽略大小写、是否进行多行匹配、是否显示调试信息等。如果需要为flags参数指定多个值，可以使用<a href="http://www.runoob.com/python/python-operators.html#ysf5" target="_blank" rel="noopener">按位或运算符</a>进行叠加，如<code>flags=re.I | re.M</code>。</p>
</blockquote>
<h4 id="例子4：拆分长字符串"><a href="#例子4：拆分长字符串" class="headerlink" title="例子4：拆分长字符串"></a>例子4：拆分长字符串</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    poem = <span class="string">'窗前明月光，疑是地上霜。举头望明月，低头思故乡。'</span></span><br><span class="line">    sentence_list = re.split(<span class="string">r'[，。, .]'</span>, poem)</span><br><span class="line">    <span class="keyword">while</span> <span class="string">''</span> <span class="keyword">in</span> sentence_list:</span><br><span class="line">        sentence_list.remove(<span class="string">''</span>)</span><br><span class="line">    print(sentence_list)  <span class="comment"># ['窗前明月光', '疑是地上霜', '举头望明月', '低头思故乡']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>如果要从事爬虫类应用的开发，那么正则表达式一定是一个非常好的助手，因为它可以帮助我们迅速的从网页代码中发现某种我们指定的模式并提取出我们需要的信息，当然对于初学者来收，要编写一个正确的适当的正则表达式可能并不是一件容易的事情（当然有些常用的正则表达式可以直接在网上找找），所以实际开发爬虫应用的时候，有很多人会选择<a href="https://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">Beautiful Soup</a>或<a href="http://lxml.de/" target="_blank" rel="noopener">Lxml</a>来进行匹配和信息的提取，前者简单方便但是性能较差，后者既好用性能也好，但是安装稍嫌麻烦，这些内容我们会在后期的爬虫专题中为大家介绍。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>10-文件和异常</title>
    <url>/2019/10/02/tutorials/Python/10.%E6%96%87%E4%BB%B6%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="10-文件和异常"><a href="#10-文件和异常" class="headerlink" title="10-文件和异常"></a>10-文件和异常</h2><p>在实际开发中，常常需要对程序中的数据进行<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96" target="_blank" rel="noopener">持久化</a>操作，而实现数据持久化最直接简单的方式就是将数据保存到文件中。说到“文件”这个词，可能需要先科普一下关于<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">文件系统</a>的知识，对于这个概念，维基百科上给出了很好的诠释，这里不再浪费笔墨。</p>
<p>在Python中实现文件的读写操作其实非常简单，通过Python内置的<code>open</code>函数，我们可以指定文件名、操作模式、编码信息等来获得操作文件的对象，接下来就可以对文件进行读写操作了。这里所说的操作模式是指要打开什么样的文件（字符文件还是二进制文件）以及做什么样的操作（读、写还是追加），具体的如下表所示。</p>
<table>
<thead>
<tr>
<th>操作模式</th>
<th>具体含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&#39;r&#39;</code></td>
<td>读取 （默认）</td>
</tr>
<tr>
<td><code>&#39;w&#39;</code></td>
<td>写入（会先截断之前的内容）</td>
</tr>
<tr>
<td><code>&#39;x&#39;</code></td>
<td>写入，如果文件已经存在会产生异常</td>
</tr>
<tr>
<td><code>&#39;a&#39;</code></td>
<td>追加，将内容写入到已有文件的末尾</td>
</tr>
<tr>
<td><code>&#39;b&#39;</code></td>
<td>二进制模式</td>
</tr>
<tr>
<td><code>&#39;t&#39;</code></td>
<td>文本模式（默认）</td>
</tr>
<tr>
<td><code>&#39;+&#39;</code></td>
<td>更新（既可以读又可以写）</td>
</tr>
</tbody></table>
<p>下面这张图来自于<a href="http://www.runoob.com" target="_blank" rel="noopener">菜鸟教程</a>网站，它展示了如果根据应用程序的需要来设置操作模式。</p>
<p><img src="./res/file-open-mode.png" alt=""></p>
<h3 id="读写文本文件"><a href="#读写文本文件" class="headerlink" title="读写文本文件"></a>读写文本文件</h3><p>读取文本文件时，需要在使用<code>open</code>函数时指定好带路径的文件名（可以使用相对路径或绝对路径）并将文件模式设置为<code>&#39;r&#39;</code>（如果不指定，默认值也是<code>&#39;r&#39;</code>），然后通过<code>encoding</code>参数指定编码（如果不指定，默认值是None，那么在读取文件时使用的是操作系统默认的编码），如果不能保证保存文件时使用的编码方式与encoding参数指定的编码方式是一致的，那么就可能因无法解码字符而导致读取失败。下面的例子演示了如何读取一个纯文本文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    f = open(<span class="string">'致橡树.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    print(f.read())</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>请注意上面的代码，如果<code>open</code>函数指定的文件并不存在或者无法打开，那么将引发异常状况导致程序崩溃。为了让代码有一定的健壮性和容错性，我们可以使用Python的异常机制对可能在运行时发生状况的代码进行适当的处理，如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    f = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = open(<span class="string">'致橡树.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        print(f.read())</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        print(<span class="string">'无法打开指定的文件!'</span>)</span><br><span class="line">    <span class="keyword">except</span> LookupError:</span><br><span class="line">        print(<span class="string">'指定了未知的编码!'</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        print(<span class="string">'读取文件时解码错误!'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> f:</span><br><span class="line">            f.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在Python中，我们可以将那些在运行时可能会出现状况的代码放在<code>try</code>代码块中，在<code>try</code>代码块的后面可以跟上一个或多个<code>except</code>来捕获可能出现的异常状况。例如在上面读取文件的过程中，文件找不到会引发<code>FileNotFoundError</code>，指定了未知的编码会引发<code>LookupError</code>，而如果读取文件时无法按指定方式解码会引发<code>UnicodeDecodeError</code>，我们在<code>try</code>后面跟上了三个<code>except</code>分别处理这三种不同的异常状况。最后我们使用<code>finally</code>代码块来关闭打开的文件，释放掉程序中获取的外部资源，由于<code>finally</code>块的代码不论程序正常还是异常都会执行到（甚至是调用了<code>sys</code>模块的<code>exit</code>函数退出Python环境，<code>finally</code>块都会被执行，因为<code>exit</code>函数实质上是引发了<code>SystemExit</code>异常），因此我们通常把<code>finally</code>块称为“总是执行代码块”，它最适合用来做释放外部资源的操作。如果不愿意在<code>finally</code>代码块中关闭文件对象释放资源，也可以使用上下文语法，通过<code>with</code>关键字指定文件对象的上下文环境并在离开上下文环境时自动释放文件资源，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'致橡树.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            print(f.read())</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        print(<span class="string">'无法打开指定的文件!'</span>)</span><br><span class="line">    <span class="keyword">except</span> LookupError:</span><br><span class="line">        print(<span class="string">'指定了未知的编码!'</span>)</span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        print(<span class="string">'读取文件时解码错误!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了使用文件对象的<code>read</code>方法读取文件之外，还可以使用<code>for-in</code>循环逐行读取或者用<code>readlines</code>方法将文件按行读取到一个列表容器中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 一次性读取整个文件内容</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'致橡树.txt'</span>, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        print(f.read())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过for-in循环逐行读取</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'致橡树.txt'</span>, mode=<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            print(line, end=<span class="string">''</span>)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 读取文件按行读取到列表中</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'致橡树.txt'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        lines = f.readlines()</span><br><span class="line">    print(lines)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>要将文本信息写入文件文件也非常简单，在使用<code>open</code>函数时指定好文件名并将文件模式设置为<code>&#39;w&#39;</code>即可。注意如果需要对文件内容进行追加式写入，应该将模式设置为<code>&#39;a&#39;</code>。如果要写入的文件不存在会自动创建文件而不是引发异常。下面的例子演示了如何将1-9999直接的素数分别写入三个文件中（1-99之间的素数保存在a.txt中，100-999之间的素数保存在b.txt中，1000-9999之间的素数保存在c.txt中）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="string">"""判断素数的函数"""</span></span><br><span class="line">    <span class="keyword">assert</span> n &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> range(<span class="number">2</span>, int(sqrt(n)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> n % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> n != <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    filenames = (<span class="string">'a.txt'</span>, <span class="string">'b.txt'</span>, <span class="string">'c.txt'</span>)</span><br><span class="line">    fs_list = []</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            fs_list.append(open(filename, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">for</span> number <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10000</span>):</span><br><span class="line">            <span class="keyword">if</span> is_prime(number):</span><br><span class="line">                <span class="keyword">if</span> number &lt; <span class="number">100</span>:</span><br><span class="line">                    fs_list[<span class="number">0</span>].write(str(number) + <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">elif</span> number &lt; <span class="number">1000</span>:</span><br><span class="line">                    fs_list[<span class="number">1</span>].write(str(number) + <span class="string">'\n'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    fs_list[<span class="number">2</span>].write(str(number) + <span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> ex:</span><br><span class="line">        print(ex)</span><br><span class="line">        print(<span class="string">'写文件时发生错误!'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">for</span> fs <span class="keyword">in</span> fs_list:</span><br><span class="line">            fs.close()</span><br><span class="line">    print(<span class="string">'操作完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="读写二进制文件"><a href="#读写二进制文件" class="headerlink" title="读写二进制文件"></a>读写二进制文件</h3><p>知道了如何读写文本文件要读写二进制文件也就很简单了，下面的代码实现了复制图片文件的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'guido.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> fs1:</span><br><span class="line">            data = fs1.read()</span><br><span class="line">            print(type(data))  <span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'吉多.jpg'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> fs2:</span><br><span class="line">            fs2.write(data)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'指定的文件无法打开.'</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'读写文件时出现错误.'</span>)</span><br><span class="line">    print(<span class="string">'程序执行结束.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="读写JSON文件"><a href="#读写JSON文件" class="headerlink" title="读写JSON文件"></a>读写JSON文件</h3><p>通过上面的讲解，我们已经知道如何将文本数据和二进制数据保存到文件中，那么这里还有一个问题，如果希望把一个列表或者一个字典中的数据保存到文件中又该怎么做呢？答案是将数据以JSON格式进行保存。JSON是“JavaScript Object Notation”的缩写，它本来是JavaScript语言中创建对象的一种字面量语法，现在已经被广泛的应用于跨平台跨语言的数据交换，原因很简单，因为JSON也是纯文本，任何系统任何编程语言处理纯文本都是没有问题的。目前JSON基本上已经取代了XML作为异构系统间交换数据的事实标准。关于JSON的知识，更多的可以参考<a href="http://json.org" target="_blank" rel="noopener">JSON的官方网站</a>，从这个网站也可以了解到每种语言处理JSON数据格式可以使用的工具或三方库，下面是一个JSON的简单例子。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'name': '骆昊',</span><br><span class="line">    'age': 38,</span><br><span class="line">    'qq': 957658,</span><br><span class="line">    'friends': ['王大锤', '白元芳'],</span><br><span class="line">    'cars': [</span><br><span class="line">        &#123;'brand': 'BYD', 'max_speed': 180&#125;,</span><br><span class="line">        &#123;'brand': 'Audi', 'max_speed': 280&#125;,</span><br><span class="line">        &#123;'brand': 'Benz', 'max_speed': 320&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可能大家已经注意到了，上面的JSON跟Python中的字典其实是一样一样的，事实上JSON的数据类型和Python的数据类型是很容易找到对应关系的，如下面两张表所示。</p>
<table>
<thead>
<tr>
<th>JSON</th>
<th>Python</th>
</tr>
</thead>
<tbody><tr>
<td>object</td>
<td>dict</td>
</tr>
<tr>
<td>array</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str</td>
</tr>
<tr>
<td>number (int / real)</td>
<td>int / float</td>
</tr>
<tr>
<td>true / false</td>
<td>True / False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Python</th>
<th>JSON</th>
</tr>
</thead>
<tbody><tr>
<td>dict</td>
<td>object</td>
</tr>
<tr>
<td>list, tuple</td>
<td>array</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>int, float, int- &amp; float-derived Enums</td>
<td>number</td>
</tr>
<tr>
<td>True / False</td>
<td>true / false</td>
</tr>
<tr>
<td>None</td>
<td>null</td>
</tr>
</tbody></table>
<p>我们使用Python中的json模块就可以将字典或列表以JSON格式保存到文件中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    mydict = &#123;</span><br><span class="line">        <span class="string">'name'</span>: <span class="string">'骆昊'</span>,</span><br><span class="line">        <span class="string">'age'</span>: <span class="number">38</span>,</span><br><span class="line">        <span class="string">'qq'</span>: <span class="number">957658</span>,</span><br><span class="line">        <span class="string">'friends'</span>: [<span class="string">'王大锤'</span>, <span class="string">'白元芳'</span>],</span><br><span class="line">        <span class="string">'cars'</span>: [</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'BYD'</span>, <span class="string">'max_speed'</span>: <span class="number">180</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'Audi'</span>, <span class="string">'max_speed'</span>: <span class="number">280</span>&#125;,</span><br><span class="line">            &#123;<span class="string">'brand'</span>: <span class="string">'Benz'</span>, <span class="string">'max_speed'</span>: <span class="number">320</span>&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'data.json'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fs:</span><br><span class="line">            json.dump(mydict, fs)</span><br><span class="line">    <span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    print(<span class="string">'保存数据完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>json模块主要有四个比较重要的函数，分别是：</p>
<ul>
<li><code>dump</code> - 将Python对象按照JSON格式序列化到文件中</li>
<li><code>dumps</code> - 将Python对象处理成JSON格式的字符串</li>
<li><code>load</code> - 将文件中的JSON数据反序列化成对象</li>
<li><code>loads</code> - 将字符串的内容反序列化成Python对象</li>
</ul>
<p>这里出现了两个概念，一个叫序列化，一个叫反序列化。自由的百科全书<a href="https://zh.wikipedia.org/" target="_blank" rel="noopener">维基百科</a>上对这两个概念是这样解释的：“序列化（serialization）在计算机科学的数据处理中，是指将数据结构或对象状态转换为可以存储或传输的形式，这样在需要的时候能够恢复到原先的状态，而且通过序列化的数据重新获取字节时，可以利用这些字节来产生原始对象的副本（拷贝）。与这个过程相反的动作，即从一系列字节中提取数据结构的操作，就是反序列化（deserialization）”。</p>
<p>目前绝大多数网络数据服务（或称之为网络API）都是基于<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTP协议</a>提供JSON格式的数据，关于HTTP协议的相关知识，可以看看阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">《HTTP协议入门》</a>，如果想了解国内的网络数据服务，可以看看<a href="https://www.juhe.cn/" target="_blank" rel="noopener">聚合数据</a>和<a href="http://www.avatardata.cn/" target="_blank" rel="noopener">阿凡达数据</a>等网站，国外的可以看看<a href="http://apis.io/" target="_blank" rel="noopener">{API}Search</a>网站。下面的例子演示了如何使用<a href="http://docs.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">requests</a>模块（封装得足够好的第三方网络访问模块）访问网络API获取国内新闻，如何通过json模块解析JSON数据并显示新闻标题，这个例子使用了<a href="https://www.tianapi.com/" target="_blank" rel="noopener">天行数据</a>提供的国内新闻数据接口，其中的APIKey需要自己到该网站申请。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    resp = requests.get(<span class="string">'http://api.tianapi.com/guonei/?key=APIKey&amp;num=10'</span>)</span><br><span class="line">    data_model = json.loads(resp.text)</span><br><span class="line">    <span class="keyword">for</span> news <span class="keyword">in</span> data_model[<span class="string">'newslist'</span>]:</span><br><span class="line">        print(news[<span class="string">'title'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在Python中要实现序列化和反序列化除了使用json模块之外，还可以使用pickle和shelve模块，但是这两个模块是使用特有的序列化协议来序列化数据，因此序列化后的数据只能被Python识别。关于这两个模块的相关知识可以自己看看网络上的资料。另外，如果要了解更多的关于Python异常机制的知识，可以看看segmentfault上面的文章<a href="https://segmentfault.com/a/1190000007736783" target="_blank" rel="noopener">《总结：Python中的异常处理》</a>，这篇文章不仅介绍了Python中异常机制的使用，还总结了一系列的最佳实践，很值得一读。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux001 Linux简介</title>
    <url>/2019/11/13/tutorials/Linux/Linux001/</url>
    <content><![CDATA[<h1 id="Linux-简介"><a href="#Linux-简介" class="headerlink" title="Linux 简介"></a>Linux 简介</h1><blockquote>
<p>本篇教程主要讲述Linux的历史背景。linux如何由来，又经过了怎样的发展，最终达到了今天这样的世界地位。</p>
</blockquote>
<p>Well，既然是甩在Blog的教程，篇幅的话，我也不管了，为了让大家能从根本上对Unix至Linux这类系统出现的意义何在 有一定的了解，so，我们不如从盘古开天地说起。</p>
<p>话说那天（ 我也不知道是哪天:) 也别来问我..请出门左转<a href="https://www.bing.com" target="_blank" rel="noopener">bing</a>），盘古一斧子给劈出了个天和地，渐渐的，天越升越高，地越沉越低，于是就出现了处于天地之间的人间…few years later…计算机就出现了（中间略）<br>所以说盘古还是挺重要的，于是我觉得有必要在这儿提一提他。此致，敬礼  </p>
<img src="/2019/11/13/tutorials/Linux/Linux001/give_a_salute.jpg" class="" title="给您敬礼了">  

<a id="more"></a>

<h2 id="计算机的前世今生"><a href="#计算机的前世今生" class="headerlink" title="计算机的前世今生"></a>计算机的前世今生</h2><h3 id="计算机软件和硬件"><a href="#计算机软件和硬件" class="headerlink" title="计算机软件和硬件"></a>计算机软件和硬件</h3><p>众所周知:) 计算机大致可以分成两大部分，<code>硬件</code>和<code>软件</code>。  </p>
<ul>
<li>只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算）  </li>
<li>只有软件没有硬件的计算机…好像这都不叫计算机了，:sweat_smile:pass…</li>
</ul>
<p>所以必须用 <strong>特定的软件</strong> 来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是 <code>操作系统</code></p>
<p>操作系统是控制和管理整个计算机系统的硬件和软件资源，合理的分配资源和调配任务，为系统用户和其他软件提供接口和环境的程序的集合 的软件。</p>
<h3 id="最早的人机交互"><a href="#最早的人机交互" class="headerlink" title="最早的人机交互"></a>最早的人机交互</h3><p>最初为了实现人机交互，是一种用打孔纸带往计算机传送0和1数据的方法。纸带如下图，具体操作过程请自行脑补…<br><img src="ibm-col80-punched-card.png" alt="打孔纸带"><br>如果都这样写你的c语言作业的话，那么 <strong>霸王</strong> 都不能拯救你的发际线了 :pensive:</p>
<p>于是，最早秃头的一群人，他们设计出了<code>批处理系统</code></p>
<h3 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h3><p>又到了我们最喜欢的ctrl-c ctrl-v的时候了 :sunglasses:</p>
<blockquote>
<p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p>
</blockquote>
<p>批处理系统已经提高了很多计算机的执行效率，终于让我们有了一点自动自动机器的感觉了。不过他们还并不满意，他们还想再让秃头的日子延迟几年，于是又出现了下一个更牛逼的东西</p>
<h3 id="分时系统和实时系统"><a href="#分时系统和实时系统" class="headerlink" title="分时系统和实时系统"></a>分时系统和实时系统</h3><p>据说程序员的键盘掉漆最快的是ctrl、c和v键 :no_mouth:</p>
<blockquote>
<p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。  </p>
<p>由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p>
</blockquote>
<p>这才是现代计算机该有的样子嘛:grin:</p>
<p>至此，对计算机的历史的简单梳理之后，计算机基本部分也该告一段落了，接下来的就该我们这一系列教程的主角 :sparkles:<strong><em>Linux</em></strong>:sparkles: 上场了。</p>
<h2 id="Linux的老前辈Unix"><a href="#Linux的老前辈Unix" class="headerlink" title="Linux的老前辈Unix"></a>Linux的老前辈Unix</h2><h3 id="Unix诞生之前"><a href="#Unix诞生之前" class="headerlink" title="Unix诞生之前"></a>Unix诞生之前</h3><p>Unix之前的计算机大部分是采用批处理的方式。那时， <strong>美国电话及电报公司（AT&amp;T）、通用电器公司（G。E。）及麻省理工学院（MIT）</strong> 计划合作开发一个多用途、分时及多用户的操作系统，也就是<code>MULTICS</code>  </p>
<p>不过，这个项目由于太过复杂，整个目标过于庞大，糅合了太多的特性，<em>进展太慢，几年下来都没有任何成果，而且性能都很低</em>。于是到了1969年2月，贝尔实验室决定退出这个项目。</p>
<h3 id="Unix-的诞生与发展"><a href="#Unix-的诞生与发展" class="headerlink" title="Unix 的诞生与发展"></a>Unix 的诞生与发展</h3><p>然而，有个叫Ken Thompson的人，他为MULTICS这个操作系统写游戏了个叫“Space Travel”的游戏，不过太贵了，运行一次要:moneybag:$75（现在想想steam的游戏还真是良心）他为了让这个游戏能玩，所以他找来Dennis Ritchie为这个游戏开发一个极其简单的操作系统。这就是后来的 <strong><em>Unix</em></strong>。当时完成Unix第一版是在1969年8月。也就是这一年，一个叫 Linus Torvalds:baby:在芬兰出生了。</p>
<p>到了1973年的时候，Ken Thompson 与Dennis Ritchie感到用汇编语言做移植太过于头痛，他们想用高级语言来完成第三版，对于当时完全以汇编语言来开发程序的年代，他们的想法算是相当的疯狂。一开始他们想尝试用<code>Fortran</code>，可是失败了。后来他们用一个叫BCPL的语言开发，他们整合了BCPL形成 <code>B语言</code> ，后来Dennis Ritchie觉得B语言还是不能满足要求，于是就改良了B语言，这就是今天的大名鼎鼎的 <code>C语言</code><br>Then , Ken Thompson 与Dennis Ritchie成功地用C语言重写了Unix的第三版内核。至此，Unix这个操作系统修改、移植相当便利，为Unix日后的普及打下了坚实的基础。而Unix和C完美地结合成为一个统一体，<code>C与Unix</code>很快成为世界的主导。</p>
<blockquote>
<p>emmm，内核，他是操作系统的一部分，你就简单地把它理解为操作系统的核心的东西，他很重要很重要很重要，不能没有，而且内核对电脑性能有很大的影响。</p>
</blockquote>
<p>后来，Unix系统被越来越多的个人，组织，公司，大学使用。可是后来AT&amp;T公司决定收回Unix的版权，因为他们看到了商机，然而 :smiling_imp:<strong><em>他的好景不长了</em></strong>。</p>
<h2 id="Linux强健的四肢和肌肉-muscle-GNU软件"><a href="#Linux强健的四肢和肌肉-muscle-GNU软件" class="headerlink" title="Linux强健的四肢和肌肉 :muscle: GNU软件"></a>Linux强健的四肢和肌肉 :muscle: GNU软件</h2><p>就如前面所说，一些人对于贝尔实验室对Unix收取版权费的行为非常不满:rage:，于是乎，Richard Stallman和一群人联合起来在1984年成立了一个组织，叫做<code>GNU</code>（GNU is Not Unix的缩写），名字里都饱含对Unix的嘲讽。并且开始了他们的<code>GNU工程</code>，做的就是写一堆电脑软件，few weeks later 大部分软件他们都写好了，然而还差了一个最重要的东西，系统内核。这时候，一个巨巨巨巨佬就登场了。</p>
<h2 id="Linux高效智慧的大脑-mortar-board-Linux内核"><a href="#Linux高效智慧的大脑-mortar-board-Linux内核" class="headerlink" title="Linux高效智慧的大脑 :mortar_board: Linux内核"></a>Linux高效智慧的大脑 :mortar_board: Linux内核</h2><p>紧接上文，GNU他们把什么都写好了，就差一个系统内核，这时候，一个人站出来了。<br>:boom:<strong><em>Linus Torvalds</em></strong>:boom:，他完成了Linux这一历史上具有里程碑意义的操作系统的最后一环 给GNU工程的软件写一个内核。</p>
<p>有所不同的是，这内核和GNU工程是处于世界各地的众多高水平的黑客们通过计算机网络来加入到Linux的开发的，并致力于把Linux打造成一个黑客操作系统。由于这些高水平的黑客的加入，Linux的发展速度空前的快:zap:，很快便发布了Linux 1.0.0版本。</p>
<p><img src="linus-torvalds.png" alt="Linus Torvalds"></p>
<h2 id="Linux-1-0-0"><a href="#Linux-1-0-0" class="headerlink" title="Linux 1.0.0"></a>Linux 1.0.0</h2><p>Linux 1.0.0功能完整，而且内核写得紧凑高效，可以充分发挥硬件的性能:computer:</p>
<p>Linux的发展不像传统的软件工程，它完全是通过网络，集合世界各地的高手而成的一套操作系统，在这里我们也可以见识到网络快速传播的威力。Linux初次让整个世界感觉到了开源力量和网络力量的如此强大。</p>
<blockquote>
<p>Linux 的标志和吉祥物是一只名字叫做 Tux 的 企鹅，标志的由来是因为Linus在澳洲时曾被一只动物园里的企鹅咬了一口，便选择了企鹅作为Linux的标志。<br><img src="tux.png" alt="Tux"><br>(emmm 图有点大，实际还是挺小挺可爱的)</p>
</blockquote>
<p>Linux 的历史是和GNU紧密联系在一起的。</p>
<p>从1983年开始的GNU计划致力于开发一个自由并且完整的类Unix操作系统，包括软件开发工具和各种应用程序。到1991年 Linux 内核发布的时候，GNU已经几乎完成了除了系统内核之外的各种必备软件的开发。在 Linus Torvalds 和其它开发人员的努力下，GNU组件可以运行于Linux内核之上。整个内核是基于 GNU 通用公共许可，也就是<code>GPL（GNU General Public License，GNU通用公共许可证）</code>的，但是Linux内核并不是GNU 计划的一部分。1994年3月，Linux1。0版正式发布，Marc Ewing成立了 <strong>Red Hat</strong> 软件公司，成为最著名的 Linux 分销商之一。</p>
<h2 id="The-Whole-Linux-penguin"><a href="#The-Whole-Linux-penguin" class="headerlink" title="The Whole Linux :penguin:"></a>The Whole Linux :penguin:</h2><p>综上所述，现在通常意义的Linux就是就是遵守GPL开源协议的 GNU project的各种software和Linux内核组成的 <code>GNU/Linux system</code>。简称 Linux 系统。</p>
<hr>
<h2 id="开源思想"><a href="#开源思想" class="headerlink" title="开源思想"></a>开源思想</h2><h3 id="可以说是开源思想的前辈—-黑客文化-man-technologist"><a href="#可以说是开源思想的前辈—-黑客文化-man-technologist" class="headerlink" title="可以说是开源思想的前辈—-黑客文化:man_technologist:"></a>可以说是开源思想的前辈—-黑客文化:man_technologist:</h3><p>黑客的文化和Unix的商业化存在着必然的联系。自从Unix出现，黑客文化就与之而来。</p>
<blockquote>
<ul>
<li><p>1993初，一个悲观的观察家撰文指出，已经有理由认为Unix的传奇故事连同他带有黑客文明将一同破产。许多人预测，从那时起Unix将在六月内死亡。他们很清楚，十年的Unix商业化，使自由跨平台的Unix梦以失败告终。Unix允诺的跨平台可移植性，在一打大公司专有的Unix版本之间不停地斗嘴中丢失，一个完美的操作系统最终沦为多种版本的一团乱麻，这应该说是人类文明史上的一个重大悲剧。</p>
</li>
<li><p>在专有软件社会中，只有像微软一样的“集权制，大教堂”生产方式才能成功。那个时代的人悲观地相信，技术世界的个人英雄主义时代已经结束，软件工业和发展中的互联网络将逐渐地由像微软一样的巨型企业支配，再也没有“佐罗”，世界是恺撒大帝的世界，计算机文明将进入黑暗的帝国时代。黑客已经死了，自由不付存在.</p>
</li>
<li><p>就在黑客文化日渐衰落之时，美国新闻周刊的资深记者Steven Levy完成了著名的《黑客列传》一书，书中着力介绍了一个人物：Richard M Stallman的故事，他是麻省理工学院（MIT）人工智能实验室领袖人物，坚决反对实验室的研究成果商业化。他是商业软件社会中坚强的一员，决不随波逐流，建立了全新的黑客文化。</p>
</li>
<li><p>只有痴迷的“黑客”和具有创造力的怪人结成的反叛联盟才能把我们从愚蠢中拯救出来——他们接着教导我们，真正的专业和奉献精神，正是我们在屈服于世俗观念的“合理商业做法”之前的所作所为。 ——《The Art of Unix Programming》</p>
</li>
<li><p>RMS让世界上所有的人都知道，入侵电脑系统只是低级不入流的黑客干的事，真正的黑客，是为了自由，为了软件的自由，为了挑战计算机世界中的霸权主义而斗争。他们不是街头小混混，他们更像是绿林好汉，更像是罗宾汉，更像是佐罗。就像渴望民主的人民同专制的政府斗争一样。RMS领导着许多的黑客通过互联网向专有软件发出宣战。</p>
</li>
</ul>
</blockquote>
<p>而这些也不可否认地对后来的开源文化有很大的启发。</p>
<h3 id="开源文化"><a href="#开源文化" class="headerlink" title="开源文化"></a>开源文化</h3><p>事到如今，开源文化已经传播到世界各地，对整个世界的经济乃至思想都造成了很大的影响。<br>自 Linus Torvalds 创建 Linux 以来，开源思想在软件界可谓盛极一时。发展到今天，开源思想传播到了软件界之外的地方，开源也不再只是开放了源代码的程序的代言词，更是一种 <strong>分享互助的精神</strong> 。他吸收了黑客文化那种团结互助和免费分享的精神，却也不是RMS那样一言否定收费，就如同Linus所说：“用自由软件是<strong>因为它运行得更好</strong>”而不是“用自由软件是因为所有软件<strong>都该是</strong>  :two_men_holding_hands:<strong>自由</strong>:two_men_holding_hands:  的”。</p>
<p>今天，我们也说不清楚是GNU Linux还是Linux GNU。Linux既不排斥开源，也不排斥商业化，Linus认为好的软件是需要免费和商业化共同推进的。正是这种革命性的想法，造就了今天的Linux火红的局面（参看《谁写了Linux》、《Linux基金会的广告》、《Linux Distribution Timeline》）。Linux就像一股清泉流入了所有人的心中，引发了很多的启迪和思考。</p>
<h2 id="全新的软件开发方式"><a href="#全新的软件开发方式" class="headerlink" title="全新的软件开发方式"></a>全新的软件开发方式</h2><p><code>X Windows</code>是首批由服务于全球各地不同组织的许多个人以团队形式开发的大规模开源项目之一。电子邮件:e-mail:使创意得以在这个群体中快速传播，问题由此得以快速解决，而开发者可以人尽其才。软件更新可以在数小时之内发送到位，使得每个节点在整个开发过程中步调一致。网络改变了软件的开发模式。</p>
<p>而这也给正在蓬勃发展的开源文化创造了绝佳的机会。事情又要从Linus创造Linux的过程说起。</p>
<h3 id="Git-Yes"><a href="#Git-Yes" class="headerlink" title="Git Yes"></a>Git Yes</h3><p>在Linus开发<code>Linux</code>的时候，为了和其他人共同开发（每人分工做不同的部分）而不造成源码、版本混乱，用了一个叫做<code>BitKeeper</code>的版本控制系统。  </p>
<p>然而他们这群人之中的有些人 <em>闲着没事干</em>？去破解Bitkeeper的源码（看看人大佬的业余爱好，还在为Linux上没有lol而不装Linux找借口？），然而被发现了（大佬也有翻车的时候），Bitkeeper公司就威胁不再给他们免费使用，于是…<del>Linus就去给他们道歉并保证要严管小弟</del>…自己用过了2周写了一个分布式版本控制系统，这就是<code>git</code>。（看看人巨巨巨佬的工作效率）并在一月内就把Linux的源码全部搬到Git上去了。</p>
<p>后来的<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>也是用的git分布式管理系统。这是全球最大的 <del>同性交友网站</del> 面向开源及私有软件项目的托管平台。</p>
<h3 id="Git-Vs-SVN-，分布式VS集中式"><a href="#Git-Vs-SVN-，分布式VS集中式" class="headerlink" title="Git Vs SVN ，分布式VS集中式"></a>Git Vs SVN ，分布式VS集中式</h3><p>emmm，自从入了冬，整个人越来越懒了（其实是马上要上数据结构课了..），连ctrl c v都不想按了，<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248" target="_blank" rel="noopener">大家自行跳转吧</a>，这也算是尊重大佬的劳动成果吧。PS：那个网站真的不错，推荐大家在上面学习的。</p>
<p>我们协会之后的什么项目啊，都会放在GitHub上的，请牢记我们的账号地址 <strong><em>github.com/OSA-NULL</em></strong><br>我们这Linux系列的教程在后续也会有git+github的使用方式，敬请期待。</p>
<h2 id="一抹多的Linux-distros-（Linux-发行版）"><a href="#一抹多的Linux-distros-（Linux-发行版）" class="headerlink" title="一抹多的Linux distros （Linux 发行版）"></a>一抹多的Linux distros （Linux 发行版）</h2><p>众所周知，由于其遵循GPL协议。你可以任意更改linux系统，更改Linux内核，换不同的Windows manager和常用的各种工具，你都可以任意组合，没有固定的搭配（除非是因为软件之间的依赖性）。这也就直接决定了Linux注定比windows更加自由，你不用再用Windows那个万年不变的window manager，资源管理器之类的。</p>
<p>在Linux上，有成千上万的window manager可供你免费下载使用，而且可供你任意修改任意一个细节。这对于喜欢自己动手的人来说，简直就是天堂，同时对于那些不怎么喜欢自己动手配置桌面环境的，在社区内也有一大堆别人开源出来的主题，总有一个你喜欢的。</p>
<p>也是因为Linux系统的这种给用户的极大的自由和权力 ，才有今天的各个发行版。发行版就是别人集成了一些东西，封装好再开源出来给别人使用的Linux系统，有开箱即用的，如 <a href="https://www.manjaro.org/" target="_blank" rel="noopener">Manjaro</a>，<a href="https://cn.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a>等等，也有从头开始自己配置的，如<a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch</a>，<a href="https://www.gentoo.org/" target="_blank" rel="noopener">Gentoo</a>等等。这也就给新手带来了最让人头疼的问题————我该用哪一个呢？？？</p>
<p>选择的关键在于</p>
<blockquote>
<ol>
<li><strong>适合自己目前的水平</strong><pre><code>比如我有一点bash命令的基础，或者我是一个什么都不知道的小白，那么我们在选择distros的时候就要考虑避开arch或者gentoo这样连安装系统都需要很多基础的发行版</code></pre></li>
<li><strong>选择我想要达到哪种水平所对应的发行版</strong><pre><code>比如，我用Linux并不需要知道Linux更深层次的东西，而是只需要使用Linux上面的优秀的软件，我也不必去追求精通Linux内核及其深层次的工作原理，那么选择一个简单上手，不用花太多的精力去配置系统的发行版比如ubuntu；相反，如果我想要去了解Linux系统的根本原理，然后我想自己配置一个完全属于自己专属的Linux系统，那么我就会去选择那些需要自己一步一步配置的发行版，比如arch。</code></pre></li>
<li><strong>（一个很重要的点）那个发行版的社区是否活跃</strong><pre><code>发行版对应的Wiki是否全面，开发组是否会随时跟进修复bug以及更新。一个好的发行版的社区很活跃，如果在使用过程中遇到了很多问题，那么一个比 百度一下 更好的方法就是~~Google it~~ 去查官方wiki或者上对应社区寻求帮助。</code></pre></li>
</ol>
</blockquote>
<p>每个发行版不存在谁更好，谁更差。各有各的特点，大家也不要跟风，说他用的arch更高级，我就也要去用arch，殊不知别人是用Linux 2年的大佬了，而自己是个刚接触Linux的newbie。也不要试图去引战，大家都是Linux大家庭的一员，谁也不想搞内斗，还是共同联合发展壮大更为重要！ 乌拉！！！ </p>
<p>至于具体各个版本的推荐，网上已经有好多了，我也就不在这儿重复了，<a href="http://baijiahao.baidu.com/s?id=1597911999197622652&wfr=spider&for=pc" target="_blank" rel="noopener">大家自行跳转</a>.<br>我在此也不去列举几个推荐的系统，因为我更推荐大家自己动手去了解各个发行版的哲学。</p>
<p><strong><em>不要人云亦云，跟风，要学会自己去判断，做个崇尚科学和逻辑的现代人，不要无脑喷，不做键盘侠</em></strong></p>
<hr>
<p>emmm，第一次教学内容大致就是这些，下一步，去实操吧，可以在windows上的虚拟机装Linux试试手，然后在真机上实操。温馨提示：数据无价，请在真机操作的时候注意备份个人重要文件。当然虚拟机的话，就随你乱玩了。</p>
<p>:vulcan_salute:祝君安:vulcan_salute:</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>09-面向对象进阶</title>
    <url>/2019/10/02/tutorials/Python/09.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="09-面向对象进阶"><a href="#09-面向对象进阶" class="headerlink" title="09-面向对象进阶"></a>09-面向对象进阶</h2><p>在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。</p>
<h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩飞行棋.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩斗地主.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    person = Person(<span class="string">'王大锤'</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python是一门<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_age'</span>, <span class="string">'_gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩飞行棋.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩斗地主.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    person = Person(<span class="string">'王大锤'</span>, <span class="number">22</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person._gender = <span class="string">'男'</span></span><br><span class="line">    <span class="comment"># AttributeError: 'Person' object has no attribute '_is_gay'</span></span><br><span class="line">    <span class="comment"># person._is_gay = True</span></span><br></pre></td></tr></table></figure>

<h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._a + self._b + self._c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        half = self.perimeter() / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sqrt(half * (half - self._a) *</span><br><span class="line">                    (half - self._b) * (half - self._c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    <span class="comment"># 静态方法和类方法都是通过给类发消息来调用的</span></span><br><span class="line">    <span class="keyword">if</span> Triangle.is_valid(a, b, c):</span><br><span class="line">        t = Triangle(a, b, c)</span><br><span class="line">        print(t.perimeter())</span><br><span class="line">        <span class="comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span></span><br><span class="line">        <span class="comment"># print(Triangle.perimeter(t))</span></span><br><span class="line">        print(t.area())</span><br><span class="line">        <span class="comment"># print(Triangle.area(t))</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'无法构成三角形.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, localtime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""数字时钟"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._hour = hour</span><br><span class="line">        self._minute = minute</span><br><span class="line">        self._second = second</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(cls)</span>:</span></span><br><span class="line">        ctime = localtime(time())</span><br><span class="line">        <span class="keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""走字"""</span></span><br><span class="line">        self._second += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._second == <span class="number">60</span>:</span><br><span class="line">            self._second = <span class="number">0</span></span><br><span class="line">            self._minute += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._minute == <span class="number">60</span>:</span><br><span class="line">                self._minute = <span class="number">0</span></span><br><span class="line">                self._hour += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self._hour == <span class="number">24</span>:</span><br><span class="line">                    self._hour = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示时间"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%02d:%02d:%02d'</span> % \</span><br><span class="line">               (self._hour, self._minute, self._second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 通过类方法创建对象并获取系统时间</span></span><br><span class="line">    clock = Clock.now()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(clock.show())</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        clock.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p>
<ul>
<li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li>
<li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li>
<li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li>
</ul>
<p>我们可以使用一种叫做<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">UML</a>（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读<a href="https://e.jd.com/30392949.html" target="_blank" rel="noopener">《UML面向对象设计基础》</a>一书。</p>
<p><img src="./res/uml-components.png" alt=""></p>
<p><img src="./res/uml-example.png" alt=""></p>
<p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p>
<h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a>。下面我们先看一个继承的例子。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""人"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s正在愉快的玩耍.'</span> % self._name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_av</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &gt;= <span class="number">18</span>:</span><br><span class="line">            print(<span class="string">'%s正在观看爱情动作片.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s只能观看《熊出没》.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""学生"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, grade)</span>:</span></span><br><span class="line">        super().__init__(name, age)</span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self, grade)</span>:</span></span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self, course)</span>:</span></span><br><span class="line">        print(<span class="string">'%s的%s正在学习%s.'</span> % (self._grade, self._name, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""老师"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, title)</span>:</span></span><br><span class="line">        super().__init__(name, age)</span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @title.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span><span class="params">(self, course)</span>:</span></span><br><span class="line">        print(<span class="string">'%s%s正在讲%s.'</span> % (self._name, self._title, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    stu = Student(<span class="string">'王大锤'</span>, <span class="number">15</span>, <span class="string">'初三'</span>)</span><br><span class="line">    stu.study(<span class="string">'数学'</span>)</span><br><span class="line">    stu.watch_av()</span><br><span class="line">    t = Teacher(<span class="string">'骆昊'</span>, <span class="number">38</span>, <span class="string">'老叫兽'</span>)</span><br><span class="line">    t.teach(<span class="string">'Python程序设计'</span>)</span><br><span class="line">    t.watch_av()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""宠物"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nickname)</span>:</span></span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发出声音"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="string">"""狗"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 汪汪汪...'</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="string">"""猫"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 喵...喵...'</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pets = [Dog(<span class="string">'旺财'</span>), Cat(<span class="string">'凯蒂'</span>), Dog(<span class="string">'大黄'</span>)]</span><br><span class="line">    <span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">        pet.make_voice()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p>
<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：奥特曼打小怪兽"><a href="#案例1：奥特曼打小怪兽" class="headerlink" title="案例1：奥特曼打小怪兽"></a>案例1：奥特曼打小怪兽</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, randrange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fighter</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""战斗者"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过__slots__魔法限定对象可以绑定的成员变量</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, hp)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._hp = hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @hp.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span><span class="params">(self, hp)</span>:</span></span><br><span class="line">        self._hp = hp <span class="keyword">if</span> hp &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._hp &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ultraman</span><span class="params">(Fighter)</span>:</span></span><br><span class="line">    <span class="string">"""奥特曼"""</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>, <span class="string">'_mp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, hp, mp)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        :param mp: 魔法值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(name, hp)</span><br><span class="line">        self._mp = mp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        other.hp -= randint(<span class="number">15</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">huge_attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""究极必杀技(打掉对方至少50点或四分之三的血)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用成功返回True否则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">50</span>:</span><br><span class="line">            self._mp -= <span class="number">50</span></span><br><span class="line">            injury = other.hp * <span class="number">3</span> // <span class="number">4</span></span><br><span class="line">            injury = injury <span class="keyword">if</span> injury &gt;= <span class="number">50</span> <span class="keyword">else</span> <span class="number">50</span></span><br><span class="line">            other.hp -= injury</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.attack(other)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magic_attack</span><span class="params">(self, others)</span>:</span></span><br><span class="line">        <span class="string">"""魔法攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param others: 被攻击的群体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用魔法成功返回True否则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">20</span>:</span><br><span class="line">            self._mp -= <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> others:</span><br><span class="line">                <span class="keyword">if</span> temp.alive:</span><br><span class="line">                    temp.hp -= randint(<span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""恢复魔法值"""</span></span><br><span class="line">        incr_point = randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        self._mp += incr_point</span><br><span class="line">        <span class="keyword">return</span> incr_point</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'~~~%s奥特曼~~~\n'</span> % self._name + \</span><br><span class="line">            <span class="string">'生命值: %d\n'</span> % self._hp + \</span><br><span class="line">            <span class="string">'魔法值: %d\n'</span> % self._mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span><span class="params">(Fighter)</span>:</span></span><br><span class="line">    <span class="string">"""小怪兽"""</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        other.hp -= randint(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'~~~%s小怪兽~~~\n'</span> % self._name + \</span><br><span class="line">            <span class="string">'生命值: %d\n'</span> % self._hp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_any_alive</span><span class="params">(monsters)</span>:</span></span><br><span class="line">    <span class="string">"""判断有没有小怪兽是活着的"""</span></span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_alive_one</span><span class="params">(monsters)</span>:</span></span><br><span class="line">    <span class="string">"""选中一只活着的小怪兽"""</span></span><br><span class="line">    monsters_len = len(monsters)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index = randrange(monsters_len)</span><br><span class="line">        monster = monsters[index]</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> monster</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_info</span><span class="params">(ultraman, monsters)</span>:</span></span><br><span class="line">    <span class="string">"""显示奥特曼和小怪兽的信息"""</span></span><br><span class="line">    print(ultraman)</span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        print(monster, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    u = Ultraman(<span class="string">'骆昊'</span>, <span class="number">1000</span>, <span class="number">120</span>)</span><br><span class="line">    m1 = Monster(<span class="string">'狄仁杰'</span>, <span class="number">250</span>)</span><br><span class="line">    m2 = Monster(<span class="string">'白元芳'</span>, <span class="number">500</span>)</span><br><span class="line">    m3 = Monster(<span class="string">'王大锤'</span>, <span class="number">750</span>)</span><br><span class="line">    ms = [m1, m2, m3]</span><br><span class="line">    fight_round = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> u.alive <span class="keyword">and</span> is_any_alive(ms):</span><br><span class="line">        print(<span class="string">'========第%02d回合========'</span> % fight_round)</span><br><span class="line">        m = select_alive_one(ms)  <span class="comment"># 选中一只小怪兽</span></span><br><span class="line">        skill = randint(<span class="number">1</span>, <span class="number">10</span>)   <span class="comment"># 通过随机数选择使用哪种技能</span></span><br><span class="line">        <span class="keyword">if</span> skill &lt;= <span class="number">6</span>:  <span class="comment"># 60%的概率使用普通攻击</span></span><br><span class="line">            print(<span class="string">'%s使用普通攻击打了%s.'</span> % (u.name, m.name))</span><br><span class="line">            u.attack(m)</span><br><span class="line">            print(<span class="string">'%s的魔法值恢复了%d点.'</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">elif</span> skill &lt;= <span class="number">9</span>:  <span class="comment"># 30%的概率使用魔法攻击(可能因魔法值不足而失败)</span></span><br><span class="line">            <span class="keyword">if</span> u.magic_attack(ms):</span><br><span class="line">                print(<span class="string">'%s使用了魔法攻击.'</span> % u.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'%s使用魔法失败.'</span> % u.name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)</span></span><br><span class="line">            <span class="keyword">if</span> u.huge_attack(m):</span><br><span class="line">                print(<span class="string">'%s使用究极必杀技虐了%s.'</span> % (u.name, m.name))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'%s使用普通攻击打了%s.'</span> % (u.name, m.name))</span><br><span class="line">                print(<span class="string">'%s的魔法值恢复了%d点.'</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">if</span> m.alive &gt; <span class="number">0</span>:  <span class="comment"># 如果选中的小怪兽没有死就回击奥特曼</span></span><br><span class="line">            print(<span class="string">'%s回击了%s.'</span> % (m.name, u.name))</span><br><span class="line">            m.attack(u)</span><br><span class="line">        display_info(u, ms)  <span class="comment"># 每个回合结束后显示奥特曼和小怪兽的信息</span></span><br><span class="line">        fight_round += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'\n========战斗结束!========\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> u.alive &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'%s奥特曼胜利!'</span> % u.name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'小怪兽胜利!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="案例2：扑克游戏"><a href="#案例2：扑克游戏" class="headerlink" title="案例2：扑克游戏"></a>案例2：扑克游戏</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""一张牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, suite, face)</span>:</span></span><br><span class="line">        self._suite = suite</span><br><span class="line">        self._face = face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">face</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._suite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._face == <span class="number">1</span>:</span><br><span class="line">            face_str = <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">11</span>:</span><br><span class="line">            face_str = <span class="string">'J'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">12</span>:</span><br><span class="line">            face_str = <span class="string">'Q'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">13</span>:</span><br><span class="line">            face_str = <span class="string">'K'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            face_str = str(self._face)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s%s'</span> % (self._suite, face_str)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""一副牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(suite, face) </span><br><span class="line">                       <span class="keyword">for</span> suite <span class="keyword">in</span> <span class="string">'♠♥♣♦'</span></span><br><span class="line">                       <span class="keyword">for</span> face <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""洗牌(随机乱序)"""</span></span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line">        random.shuffle(self._cards)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发牌"""</span></span><br><span class="line">        card = self._cards[self._current]</span><br><span class="line">        self._current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""还有没有牌"""</span></span><br><span class="line">        <span class="keyword">return</span> self._current &lt; len(self._cards)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""玩家"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._cards_on_hand = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards_on_hand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards_on_hand</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, card)</span>:</span></span><br><span class="line">        <span class="string">"""摸牌"""</span></span><br><span class="line">        self._cards_on_hand.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrange</span><span class="params">(self, card_key)</span>:</span></span><br><span class="line">        <span class="string">"""玩家整理手上的牌"""</span></span><br><span class="line">        self._cards_on_hand.sort(key=card_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序规则-先根据花色再根据点数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (card.suite, card.face)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = Poker()</span><br><span class="line">    p.shuffle()</span><br><span class="line">    players = [Player(<span class="string">'东邪'</span>), Player(<span class="string">'西毒'</span>), Player(<span class="string">'南帝'</span>), Player(<span class="string">'北丐'</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get(p.next)</span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">        print(player.name + <span class="string">':'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        player.arrange(get_key)</span><br><span class="line">        print(player.cards_on_hand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。</p>
</blockquote>
<h4 id="案例3：工资结算系统"><a href="#案例3：工资结算系统" class="headerlink" title="案例3：工资结算系统"></a>案例3：工资结算系统</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">某公司有三种类型的员工 分别是部门经理、程序员和销售员</span></span><br><span class="line"><span class="string">需要设计一个工资结算系统 根据提供的员工信息来计算月薪</span></span><br><span class="line"><span class="string">部门经理的月薪是每月固定15000元</span></span><br><span class="line"><span class="string">程序员的月薪按本月工作时间计算 每小时150元</span></span><br><span class="line"><span class="string">销售员的月薪是1200元的底薪加上销售额5%的提成</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""员工"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 姓名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获得月薪</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 月薪</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""部门经理"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""程序员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, working_hour=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self._working_hour = working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @working_hour.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span><span class="params">(self, working_hour)</span>:</span></span><br><span class="line">        self._working_hour = working_hour <span class="keyword">if</span> working_hour &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">150.0</span> * self._working_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""销售员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sales=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self._sales = sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @sales.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span><span class="params">(self, sales)</span>:</span></span><br><span class="line">        self._sales = sales <span class="keyword">if</span> sales &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1200.0</span> + self._sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    emps = [</span><br><span class="line">        Manager(<span class="string">'刘备'</span>), Programmer(<span class="string">'诸葛亮'</span>),</span><br><span class="line">        Manager(<span class="string">'曹操'</span>), Salesman(<span class="string">'荀彧'</span>),</span><br><span class="line">        Salesman(<span class="string">'吕布'</span>), Programmer(<span class="string">'张辽'</span>),</span><br><span class="line">        Programmer(<span class="string">'赵云'</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="keyword">if</span> isinstance(emp, Programmer):</span><br><span class="line">            emp.working_hour = int(input(<span class="string">'请输入%s本月工作时间: '</span> % emp.name))</span><br><span class="line">        <span class="keyword">elif</span> isinstance(emp, Salesman):</span><br><span class="line">            emp.sales = float(input(<span class="string">'请输入%s本月销售额: '</span> % emp.name))</span><br><span class="line">        <span class="comment"># 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)</span></span><br><span class="line">        print(<span class="string">'%s本月工资为: ￥%s元'</span> %</span><br><span class="line">              (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>07-字符串和常用数据结构</title>
    <url>/2019/10/02/tutorials/Python/07.%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="07-字符串和常用数据结构"><a href="#07-字符串和常用数据结构" class="headerlink" title="07-字符串和常用数据结构"></a>07-字符串和常用数据结构</h2><h3 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h3><p>第二次世界大战促使了现代电子计算机的诞生，当初的想法很简单，就是用计算机来计算导弹的弹道，因此在计算机刚刚诞生的那个年代，计算机处理的信息主要是数值，而世界上的第一台电子计算机ENIAC每秒钟能够完成约5000次浮点运算。随着时间的推移，虽然对数值运算仍然是计算机日常工作中最为重要的事情之一，但是今天的计算机处理得更多的数据都是以文本信息的方式存在的，而Python表示文本信息的方式我们在很早以前就说过了，那就是字符串类型。所谓<strong>字符串</strong>，就是由零个或多个字符组成的有限序列，一般记为<a href="https://wikimedia.org/api/rest_v1/media/math/render/svg/e29bf631b090323edd6889f810e6cff29538b161" target="_blank" rel="noopener">$${\displaystyle s=a_{1}a_{2}\dots a_{n}(0\leq n \leq \infty)}$$</a>。</p>
<p>我们可以通过下面的代码来了解字符串的使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    str1 = <span class="string">'hello, world!'</span></span><br><span class="line">    <span class="comment"># 通过len函数计算字符串的长度</span></span><br><span class="line">    print(len(str1))  <span class="comment"># 13</span></span><br><span class="line">    <span class="comment"># 获得字符串首字母大写的拷贝</span></span><br><span class="line">    print(str1.capitalize())  <span class="comment"># Hello, world!</span></span><br><span class="line">    <span class="comment"># 获得字符串变大写后的拷贝</span></span><br><span class="line">    print(str1.upper())  <span class="comment"># HELLO, WORLD!</span></span><br><span class="line">    <span class="comment"># 从字符串中查找子串所在位置</span></span><br><span class="line">    print(str1.find(<span class="string">'or'</span>))  <span class="comment"># 8</span></span><br><span class="line">    print(str1.find(<span class="string">'shit'</span>))  <span class="comment"># -1</span></span><br><span class="line">    <span class="comment"># 与find类似但找不到子串时会引发异常</span></span><br><span class="line">    <span class="comment"># print(str1.index('or'))</span></span><br><span class="line">    <span class="comment"># print(str1.index('shit'))</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以指定的字符串开头</span></span><br><span class="line">    print(str1.startswith(<span class="string">'He'</span>))  <span class="comment"># False</span></span><br><span class="line">    print(str1.startswith(<span class="string">'hel'</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以指定的字符串结尾</span></span><br><span class="line">    print(str1.endswith(<span class="string">'!'</span>))  <span class="comment"># True</span></span><br><span class="line">    <span class="comment"># 将字符串以指定的宽度居中并在两侧填充指定的字符</span></span><br><span class="line">    print(str1.center(<span class="number">50</span>, <span class="string">'*'</span>))</span><br><span class="line">    <span class="comment"># 将字符串以指定的宽度靠右放置左侧填充指定的字符</span></span><br><span class="line">    print(str1.rjust(<span class="number">50</span>, <span class="string">' '</span>))</span><br><span class="line">    str2 = <span class="string">'abc123456'</span></span><br><span class="line">    <span class="comment"># 从字符串中取出指定位置的字符(下标运算)</span></span><br><span class="line">    print(str2[<span class="number">2</span>])  <span class="comment"># c</span></span><br><span class="line">    <span class="comment"># 字符串切片(从指定的开始索引到指定的结束索引)</span></span><br><span class="line">    print(str2[<span class="number">2</span>:<span class="number">5</span>])  <span class="comment"># c12</span></span><br><span class="line">    print(str2[<span class="number">2</span>:])  <span class="comment"># c123456</span></span><br><span class="line">    print(str2[<span class="number">2</span>::<span class="number">2</span>])  <span class="comment"># c246</span></span><br><span class="line">    print(str2[::<span class="number">2</span>])  <span class="comment"># ac246</span></span><br><span class="line">    print(str2[::<span class="number">-1</span>])  <span class="comment"># 654321cba</span></span><br><span class="line">    print(str2[<span class="number">-3</span>:<span class="number">-1</span>])  <span class="comment"># 45</span></span><br><span class="line">    <span class="comment"># 检查字符串是否由数字构成</span></span><br><span class="line">    print(str2.isdigit())  <span class="comment"># False</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以字母构成</span></span><br><span class="line">    print(str2.isalpha())  <span class="comment"># False</span></span><br><span class="line">    <span class="comment"># 检查字符串是否以数字和字母构成</span></span><br><span class="line">    print(str2.isalnum())  <span class="comment"># True</span></span><br><span class="line">    str3 = <span class="string">'  jackfrued@126.com '</span></span><br><span class="line">    print(str3)</span><br><span class="line">    <span class="comment"># 获得字符串修剪左右两侧空格的拷贝</span></span><br><span class="line">    print(str3.strip())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了字符串，Python还内置了多种类型的数据结构，如果要在程序中保存和操作数据，绝大多数时候可以利用现有的数据结构来实现，最常用的包括列表、元组、集合和字典。</p>
<h3 id="使用列表"><a href="#使用列表" class="headerlink" title="使用列表"></a>使用列表</h3><p>下面的代码演示了如何定义列表、使用下标访问列表元素以及添加和删除元素的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    list1 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">100</span>]</span><br><span class="line">    print(list1)</span><br><span class="line">    list2 = [<span class="string">'hello'</span>] * <span class="number">5</span></span><br><span class="line">    print(list2)</span><br><span class="line">    <span class="comment"># 计算列表长度(元素个数)</span></span><br><span class="line">    print(len(list1))</span><br><span class="line">    <span class="comment"># 下标(索引)运算</span></span><br><span class="line">    print(list1[<span class="number">0</span>])</span><br><span class="line">    print(list1[<span class="number">4</span>])</span><br><span class="line">    <span class="comment"># print(list1[5])  # IndexError: list index out of range</span></span><br><span class="line">    print(list1[<span class="number">-1</span>])</span><br><span class="line">    print(list1[<span class="number">-3</span>])</span><br><span class="line">    list1[<span class="number">2</span>] = <span class="number">300</span></span><br><span class="line">    print(list1)</span><br><span class="line">    <span class="comment"># 添加元素</span></span><br><span class="line">    list1.append(<span class="number">200</span>)</span><br><span class="line">    list1.insert(<span class="number">1</span>, <span class="number">400</span>)</span><br><span class="line">    list1 += [<span class="number">1000</span>, <span class="number">2000</span>]</span><br><span class="line">    print(list1)</span><br><span class="line">    print(len(list1))</span><br><span class="line">    <span class="comment"># 删除元素</span></span><br><span class="line">    list1.remove(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">1234</span> <span class="keyword">in</span> list1:</span><br><span class="line">        list1.remove(<span class="number">1234</span>)</span><br><span class="line">    <span class="keyword">del</span> list1[<span class="number">0</span>]</span><br><span class="line">    print(list1)</span><br><span class="line">    <span class="comment"># 清空列表元素</span></span><br><span class="line">    list1.clear()</span><br><span class="line">    print(list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>和字符串一样，列表也可以做切片操作，通过切片操作我们可以实现对列表的复制或者将列表中的一部分取出来创建出新的列表，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    fruits = [<span class="string">'grape'</span>, <span class="string">'apple'</span>, <span class="string">'strawberry'</span>, <span class="string">'waxberry'</span>]</span><br><span class="line">	fruits += [<span class="string">'pitaya'</span>, <span class="string">'pear'</span>, <span class="string">'mango'</span>]</span><br><span class="line">	<span class="comment"># 循环遍历列表元素</span></span><br><span class="line">    <span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">        print(fruit.title(), end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="comment"># 列表切片</span></span><br><span class="line">    fruits2 = fruits[<span class="number">1</span>:<span class="number">4</span>]</span><br><span class="line">    print(fruits2)</span><br><span class="line">    <span class="comment"># fruit3 = fruits  # 没有复制列表只创建了新的引用</span></span><br><span class="line">    <span class="comment"># 可以通过完整切片操作来复制列表</span></span><br><span class="line">    fruits3 = fruits[:]</span><br><span class="line">    print(fruits3)</span><br><span class="line">    fruits4 = fruits[<span class="number">-3</span>:<span class="number">-1</span>]</span><br><span class="line">    print(fruits4)</span><br><span class="line">    <span class="comment"># 可以通过反向切片操作来获得倒转后的列表的拷贝</span></span><br><span class="line">    fruits5 = fruits[::<span class="number">-1</span>]</span><br><span class="line">    print(fruits5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>下面的代码实现了对列表的排序操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    list1 = [<span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'zoo'</span>, <span class="string">'internationalization'</span>, <span class="string">'blueberry'</span>]</span><br><span class="line">    list2 = sorted(list1)</span><br><span class="line">    <span class="comment"># sorted函数返回列表排序后的拷贝不会修改传入的列表</span></span><br><span class="line">    <span class="comment"># 函数的设计就应该像sorted函数一样尽可能不产生副作用</span></span><br><span class="line">    list3 = sorted(list1, reverse=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序</span></span><br><span class="line">    list4 = sorted(list1, key=len)</span><br><span class="line">    print(list1)</span><br><span class="line">    print(list2)</span><br><span class="line">    print(list3)</span><br><span class="line">    print(list4)</span><br><span class="line">    <span class="comment"># 给列表对象发出排序消息直接在列表对象上进行排序</span></span><br><span class="line">    list1.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">    print(list1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们还可以使用列表的生成式语法来创建列表，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    f = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>)]</span><br><span class="line">    print(f)</span><br><span class="line">    f = [x + y <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">'ABCDE'</span> <span class="keyword">for</span> y <span class="keyword">in</span> <span class="string">'1234567'</span>]</span><br><span class="line">    print(f)</span><br><span class="line">    <span class="comment"># 用列表的生成表达式语法创建列表容器</span></span><br><span class="line">    <span class="comment"># 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间</span></span><br><span class="line">    f = [x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000</span>)]</span><br><span class="line">    print(sys.getsizeof(f))  <span class="comment"># 查看对象占用内存的字节数</span></span><br><span class="line">    print(f)</span><br><span class="line">    <span class="comment"># 请注意下面的代码创建的不是一个列表而是一个生成器对象</span></span><br><span class="line">    <span class="comment"># 通过生成器可以获取到数据但它不占用额外的空间存储数据</span></span><br><span class="line">    <span class="comment"># 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间)</span></span><br><span class="line">    f = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">1000</span>))</span><br><span class="line">    print(sys.getsizeof(f))  <span class="comment"># 相比生成式生成器不占用存储数据的空间</span></span><br><span class="line">    print(f)</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> f:</span><br><span class="line">        print(val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>除了上面提到的生成器语法，Python中还有另外一种定义生成器的方式，就是通过<code>yield</code>关键字将一个普通函数改造成生成器函数。下面的代码演示了如何实现一个生成<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波拉切数列</a>的生成器。所谓斐波拉切数列可以通过下面<a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">递归</a>的方法来进行定义：</p>
<p>$${\displaystyle F_{0}=0}$$</p>
<p>$${\displaystyle F_{1}=1}$$</p>
<p>$${\displaystyle F_{n}=F_{n-1}+F_{n-2}}({n}\geq{2})$$</p>
<p><img src="./res/fibonacci-blocks.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> fib(<span class="number">20</span>):</span><br><span class="line">        print(val)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="使用元组"><a href="#使用元组" class="headerlink" title="使用元组"></a>使用元组</h3><p>Python 的元组与列表类似，不同之处在于元组的元素不能修改，在前面的代码中我们已经不止一次使用过元组了。顾名思义，我们把多个元素组合到一起就形成了一个元组，所以它和列表一样可以保存多条数据。下面的代码演示了如何定义和使用元组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 定义元组</span></span><br><span class="line">    t = (<span class="string">'骆昊'</span>, <span class="number">38</span>, <span class="literal">True</span>, <span class="string">'四川成都'</span>)</span><br><span class="line">    print(t)</span><br><span class="line">    <span class="comment"># 获取元组中的元素</span></span><br><span class="line">    print(t[<span class="number">0</span>])</span><br><span class="line">    print(t[<span class="number">3</span>])</span><br><span class="line">    <span class="comment"># 遍历元组中的值</span></span><br><span class="line">    <span class="keyword">for</span> member <span class="keyword">in</span> t:</span><br><span class="line">        print(member)</span><br><span class="line">    <span class="comment"># 重新给元组赋值</span></span><br><span class="line">    <span class="comment"># t[0] = '王大锤'  # TypeError</span></span><br><span class="line">    <span class="comment"># 变量t重新引用了新的元组原来的元组将被垃圾回收</span></span><br><span class="line">    t = (<span class="string">'王大锤'</span>, <span class="number">20</span>, <span class="literal">True</span>, <span class="string">'云南昆明'</span>)</span><br><span class="line">    print(t)</span><br><span class="line">    <span class="comment"># 将元组转换成列表</span></span><br><span class="line">    person = list(t)</span><br><span class="line">    print(person)</span><br><span class="line">    <span class="comment"># 列表是可以修改它的元素的</span></span><br><span class="line">    person[<span class="number">0</span>] = <span class="string">'李小龙'</span></span><br><span class="line">    person[<span class="number">1</span>] = <span class="number">25</span></span><br><span class="line">    print(person)</span><br><span class="line">    <span class="comment"># 将列表转换成元组</span></span><br><span class="line">    fruits_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'orange'</span>]</span><br><span class="line">    fruits_tuple = tuple(fruits_list)</span><br><span class="line">    print(fruits_tuple)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？</p>
<ol>
<li>元组中的元素是无法修改的，事实上我们在项目中尤其是<a href="https://zh.wikipedia.org/zh-hans/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">多线程</a>环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择。</li>
<li>元组在创建时间和占用的空间上面都优于列表。我们可以使用sys模块的getsizeof函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在ipython中使用魔法指令%timeit来分析创建同样内容的元组和列表所花费的时间，下图是我的macOS系统上测试的结果。</li>
</ol>
<p><img src="./res/ipython-timeit.png" alt=""></p>
<h3 id="使用集合"><a href="#使用集合" class="headerlink" title="使用集合"></a>使用集合</h3><p>Python中的集合跟数学上的集合是一致的，不允许有重复元素，而且可以进行交集、并集、差集等运算。</p>
<p><img src="./res/python-set.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    set1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>&#125;</span><br><span class="line">    print(set1)</span><br><span class="line">    print(<span class="string">'Length ='</span>, len(set1))</span><br><span class="line">    set2 = set(range(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line">    print(set2)</span><br><span class="line">    set1.add(<span class="number">4</span>)</span><br><span class="line">    set1.add(<span class="number">5</span>)</span><br><span class="line">    set2.update([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line">    print(set1)</span><br><span class="line">    print(set2)</span><br><span class="line">    set2.discard(<span class="number">5</span>)</span><br><span class="line">    <span class="comment"># remove的元素如果不存在会引发KeyError</span></span><br><span class="line">    <span class="keyword">if</span> <span class="number">4</span> <span class="keyword">in</span> set2:</span><br><span class="line">        set2.remove(<span class="number">4</span>)</span><br><span class="line">    print(set2)</span><br><span class="line">    <span class="comment"># 遍历集合容器</span></span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> set2:</span><br><span class="line">        print(elem ** <span class="number">2</span>, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line">    <span class="comment"># 将元组转换成集合</span></span><br><span class="line">    set3 = set((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line">    print(set3.pop())</span><br><span class="line">    print(set3)</span><br><span class="line">    <span class="comment"># 集合的交集、并集、差集、对称差运算</span></span><br><span class="line">    print(set1 &amp; set2)</span><br><span class="line">    <span class="comment"># print(set1.intersection(set2))</span></span><br><span class="line">    print(set1 | set2)</span><br><span class="line">    <span class="comment"># print(set1.union(set2))</span></span><br><span class="line">    print(set1 - set2)</span><br><span class="line">    <span class="comment"># print(set1.difference(set2))</span></span><br><span class="line">    print(set1 ^ set2)</span><br><span class="line">    <span class="comment"># print(set1.symmetric_difference(set2))</span></span><br><span class="line">    <span class="comment"># 判断子集和超集</span></span><br><span class="line">    print(set2 &lt;= set1)</span><br><span class="line">    <span class="comment"># print(set2.issubset(set1))</span></span><br><span class="line">    print(set3 &lt;= set1)</span><br><span class="line">    <span class="comment"># print(set3.issubset(set1))</span></span><br><span class="line">    print(set1 &gt;= set2)</span><br><span class="line">    <span class="comment"># print(set1.issuperset(set2))</span></span><br><span class="line">    print(set1 &gt;= set3)</span><br><span class="line">    <span class="comment"># print(set1.issuperset(set3))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：Python中允许通过一些特殊的方法来为某种类型或数据结构自定义运算符（后面的章节中会讲到），上面的代码中我们对集合进行运算的时候可以调用集合对象的方法，也可以直接使用对应的运算符，例如<code>&amp;</code>运算符跟intersection方法的作用就是一样的，但是使用运算符让代码更加直观。</p>
</blockquote>
<h3 id="使用字典"><a href="#使用字典" class="headerlink" title="使用字典"></a>使用字典</h3><p>字典是另一种可变容器模型，类似于我们生活中使用的字典，它可以存储任意类型对象，与列表、集合不同的是，字典的每个元素都是由一个键和一个值组成的“键值对”，键和值通过冒号分开。下面的代码演示了如何定义和使用字典。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    scores = &#123;<span class="string">'骆昊'</span>: <span class="number">95</span>, <span class="string">'白元芳'</span>: <span class="number">78</span>, <span class="string">'狄仁杰'</span>: <span class="number">82</span>&#125;</span><br><span class="line">    <span class="comment"># 通过键可以获取字典中对应的值</span></span><br><span class="line">    print(scores[<span class="string">'骆昊'</span>])</span><br><span class="line">    print(scores[<span class="string">'狄仁杰'</span>])</span><br><span class="line">    <span class="comment"># 对字典进行遍历(遍历的其实是键再通过键取对应的值)</span></span><br><span class="line">    <span class="keyword">for</span> elem <span class="keyword">in</span> scores:</span><br><span class="line">        print(<span class="string">'%s\t---&gt;\t%d'</span> % (elem, scores[elem]))</span><br><span class="line">    <span class="comment"># 更新字典中的元素</span></span><br><span class="line">    scores[<span class="string">'白元芳'</span>] = <span class="number">65</span></span><br><span class="line">    scores[<span class="string">'诸葛王朗'</span>] = <span class="number">71</span></span><br><span class="line">    scores.update(冷面=<span class="number">67</span>, 方启鹤=<span class="number">85</span>)</span><br><span class="line">    print(scores)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'武则天'</span> <span class="keyword">in</span> scores:</span><br><span class="line">        print(scores[<span class="string">'武则天'</span>])</span><br><span class="line">    print(scores.get(<span class="string">'武则天'</span>))</span><br><span class="line">    <span class="comment"># get方法也是通过键获取对应的值但是可以设置默认值</span></span><br><span class="line">    print(scores.get(<span class="string">'武则天'</span>, <span class="number">60</span>))</span><br><span class="line">    <span class="comment"># 删除字典中的元素</span></span><br><span class="line">    print(scores.popitem())</span><br><span class="line">    print(scores.popitem())</span><br><span class="line">    print(scores.pop(<span class="string">'骆昊'</span>, <span class="number">100</span>))</span><br><span class="line">    <span class="comment"># 清空字典</span></span><br><span class="line">    scores.clear()</span><br><span class="line">    print(scores)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：在屏幕上显示跑马灯文字"><a href="#练习1：在屏幕上显示跑马灯文字" class="headerlink" title="练习1：在屏幕上显示跑马灯文字"></a>练习1：在屏幕上显示跑马灯文字</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    content = <span class="string">'北京欢迎你为你开天辟地…………'</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 清理屏幕上的输出</span></span><br><span class="line">        os.system(<span class="string">'cls'</span>)  <span class="comment"># os.system('clear')</span></span><br><span class="line">        print(content)</span><br><span class="line">        <span class="comment"># 休眠200毫秒</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        content = content[<span class="number">1</span>:] + content[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。"><a href="#练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。" class="headerlink" title="练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。"></a>练习2：设计一个函数产生指定长度的验证码，验证码由大小写字母和数字构成。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_code</span><span class="params">(code_len=<span class="number">4</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    生成指定长度的验证码</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param code_len: 验证码的长度(默认4个字符)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :return: 由大小写英文字母和数字构成的随机验证码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    all_chars = <span class="string">'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'</span></span><br><span class="line">    last_pos = len(all_chars) - <span class="number">1</span></span><br><span class="line">    code = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(code_len):</span><br><span class="line">        index = random.randint(<span class="number">0</span>, last_pos)</span><br><span class="line">        code += all_chars[index]</span><br><span class="line">    <span class="keyword">return</span> code</span><br></pre></td></tr></table></figure>

<h4 id="练习3：设计一个函数返回给定文件名的后缀名。"><a href="#练习3：设计一个函数返回给定文件名的后缀名。" class="headerlink" title="练习3：设计一个函数返回给定文件名的后缀名。"></a>练习3：设计一个函数返回给定文件名的后缀名。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_suffix</span><span class="params">(filename, has_dot=False)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件名的后缀名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param filename: 文件名</span></span><br><span class="line"><span class="string">    :param has_dot: 返回的后缀名是否需要带点</span></span><br><span class="line"><span class="string">    :return: 文件的后缀名</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    pos = filename.rfind(<span class="string">'.'</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="number">0</span> &lt; pos &lt; len(filename) - <span class="number">1</span>:</span><br><span class="line">        index = pos <span class="keyword">if</span> has_dot <span class="keyword">else</span> pos + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> filename[index:]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure>

<h4 id="练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。"><a href="#练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。" class="headerlink" title="练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。"></a>练习4：设计一个函数返回传入的列表中最大和第二大的元素的值。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max2</span><span class="params">(x)</span>:</span></span><br><span class="line">    m1, m2 = (x[<span class="number">0</span>], x[<span class="number">1</span>]) <span class="keyword">if</span> x[<span class="number">0</span>] &gt; x[<span class="number">1</span>] <span class="keyword">else</span> (x[<span class="number">1</span>], x[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">2</span>, len(x)):</span><br><span class="line">        <span class="keyword">if</span> x[index] &gt; m1:</span><br><span class="line">            m2 = m1</span><br><span class="line">            m1 = x[index]</span><br><span class="line">        <span class="keyword">elif</span> x[index] &gt; m2:</span><br><span class="line">            m2 = x[index]</span><br><span class="line">    <span class="keyword">return</span> m1, m2</span><br></pre></td></tr></table></figure>

<h4 id="练习5：计算指定的年月日是这一年的第几天"><a href="#练习5：计算指定的年月日是这一年的第几天" class="headerlink" title="练习5：计算指定的年月日是这一年的第几天"></a>练习5：计算指定的年月日是这一年的第几天</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_leap_year</span><span class="params">(year)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    判断指定的年份是不是闰年</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param year: 年份</span></span><br><span class="line"><span class="string">    :return: 闰年返回True平年返回False</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> year % <span class="number">4</span> == <span class="number">0</span> <span class="keyword">and</span> year % <span class="number">100</span> != <span class="number">0</span> <span class="keyword">or</span> year % <span class="number">400</span> == <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">which_day</span><span class="params">(year, month, date)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    计算传入的日期是这一年的第几天</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param year: 年</span></span><br><span class="line"><span class="string">    :param month: 月</span></span><br><span class="line"><span class="string">    :param date: 日</span></span><br><span class="line"><span class="string">    :return: 第几天</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    days_of_month = [</span><br><span class="line">        [<span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>],</span><br><span class="line">        [<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>]</span><br><span class="line">    ][is_leap_year(year)]</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(month - <span class="number">1</span>):</span><br><span class="line">        total += days_of_month[index]</span><br><span class="line">    <span class="keyword">return</span> total + date</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(which_day(<span class="number">1980</span>, <span class="number">11</span>, <span class="number">28</span>))</span><br><span class="line">    print(which_day(<span class="number">1981</span>, <span class="number">12</span>, <span class="number">31</span>))</span><br><span class="line">    print(which_day(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    print(which_day(<span class="number">2016</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="练习6：打印杨辉三角。"><a href="#练习6：打印杨辉三角。" class="headerlink" title="练习6：打印杨辉三角。"></a>练习6：打印<a href="https://zh.wikipedia.org/wiki/%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92%E5%BD%A2" target="_blank" rel="noopener">杨辉三角</a>。</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    num = int(input(<span class="string">'Number of rows: '</span>))</span><br><span class="line">    yh = [[]] * num</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> range(len(yh)):</span><br><span class="line">        yh[row] = [<span class="literal">None</span>] * (row + <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> range(len(yh[row])):</span><br><span class="line">            <span class="keyword">if</span> col == <span class="number">0</span> <span class="keyword">or</span> col == row:</span><br><span class="line">                yh[row][col] = <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                yh[row][col] = yh[row - <span class="number">1</span>][col] + yh[row - <span class="number">1</span>][col - <span class="number">1</span>]</span><br><span class="line">            print(yh[row][col], end=<span class="string">'\t'</span>)</span><br><span class="line">        print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：双色球选号"><a href="#案例1：双色球选号" class="headerlink" title="案例1：双色球选号"></a>案例1：双色球选号</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randrange, randint, sample</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(balls)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    输出列表中的双色球号码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> index, ball <span class="keyword">in</span> enumerate(balls):</span><br><span class="line">        <span class="keyword">if</span> index == len(balls) - <span class="number">1</span>:</span><br><span class="line">            print(<span class="string">'|'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        print(<span class="string">'%02d'</span> % ball, end=<span class="string">' '</span>)</span><br><span class="line">    print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_select</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    随机选择一组号码</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    red_balls = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">34</span>)]</span><br><span class="line">    selected_balls = []</span><br><span class="line">    selected_balls = sample(red_balls, <span class="number">6</span>)</span><br><span class="line">    selected_balls.sort()</span><br><span class="line">    selected_balls.append(randint(<span class="number">1</span>, <span class="number">16</span>))</span><br><span class="line">    <span class="keyword">return</span> selected_balls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    n = int(input(<span class="string">'机选几注: '</span>))</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        display(random_select())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：上面使用random模块的sample函数来实现从列表中选择不重复的n个元素。</p>
</blockquote>
<h4 id="综合案例2：约瑟夫环问题"><a href="#综合案例2：约瑟夫环问题" class="headerlink" title="综合案例2：约瑟夫环问题"></a>综合案例2：<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">约瑟夫环问题</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">《幸运的基督徒》</span></span><br><span class="line"><span class="string">有15个基督徒和15个非基督徒在海上遇险，为了能让一部分人活下来不得不将其中15个人扔到海里面去，有个人想了个办法就是大家围成一个圈，由某个人开始从1报数，报到9的人就扔到海里面，他后面的人接着从1开始报数，报到9的人继续扔到海里面，直到扔掉15个人。由于上帝的保佑，15个基督徒都幸免于难，问这些人最开始是怎么站的，哪些位置是基督徒哪些位置是非基督徒。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    persons = [<span class="literal">True</span>] * <span class="number">30</span></span><br><span class="line">    counter, index, number = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">15</span>:</span><br><span class="line">        <span class="keyword">if</span> persons[index]:</span><br><span class="line">            number += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> number == <span class="number">9</span>:</span><br><span class="line">                persons[index] = <span class="literal">False</span></span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                number = <span class="number">0</span></span><br><span class="line">        index += <span class="number">1</span></span><br><span class="line">        index %= <span class="number">30</span></span><br><span class="line">    <span class="keyword">for</span> person <span class="keyword">in</span> persons:</span><br><span class="line">        print(<span class="string">'基'</span> <span class="keyword">if</span> person <span class="keyword">else</span> <span class="string">'非'</span>, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="综合案例3：井字棋游戏"><a href="#综合案例3：井字棋游戏" class="headerlink" title="综合案例3：井字棋游戏"></a>综合案例3：<a href="https://zh.wikipedia.org/wiki/%E4%BA%95%E5%AD%97%E6%A3%8B" target="_blank" rel="noopener">井字棋</a>游戏</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_board</span><span class="params">(board)</span>:</span></span><br><span class="line">    print(board[<span class="string">'TL'</span>] + <span class="string">'|'</span> + board[<span class="string">'TM'</span>] + <span class="string">'|'</span> + board[<span class="string">'TR'</span>])</span><br><span class="line">    print(<span class="string">'-+-+-'</span>)</span><br><span class="line">    print(board[<span class="string">'ML'</span>] + <span class="string">'|'</span> + board[<span class="string">'MM'</span>] + <span class="string">'|'</span> + board[<span class="string">'MR'</span>])</span><br><span class="line">    print(<span class="string">'-+-+-'</span>)</span><br><span class="line">    print(board[<span class="string">'BL'</span>] + <span class="string">'|'</span> + board[<span class="string">'BM'</span>] + <span class="string">'|'</span> + board[<span class="string">'BR'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    init_board = &#123;</span><br><span class="line">        <span class="string">'TL'</span>: <span class="string">' '</span>, <span class="string">'TM'</span>: <span class="string">' '</span>, <span class="string">'TR'</span>: <span class="string">' '</span>,</span><br><span class="line">        <span class="string">'ML'</span>: <span class="string">' '</span>, <span class="string">'MM'</span>: <span class="string">' '</span>, <span class="string">'MR'</span>: <span class="string">' '</span>,</span><br><span class="line">        <span class="string">'BL'</span>: <span class="string">' '</span>, <span class="string">'BM'</span>: <span class="string">' '</span>, <span class="string">'BR'</span>: <span class="string">' '</span></span><br><span class="line">    &#125;</span><br><span class="line">    begin = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> begin:</span><br><span class="line">        curr_board = init_board.copy()</span><br><span class="line">        begin = <span class="literal">False</span></span><br><span class="line">        turn = <span class="string">'x'</span></span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        os.system(<span class="string">'clear'</span>)</span><br><span class="line">        print_board(curr_board)</span><br><span class="line">        <span class="keyword">while</span> counter &lt; <span class="number">9</span>:</span><br><span class="line">            move = input(<span class="string">'轮到%s走棋, 请输入位置: '</span> % turn)</span><br><span class="line">            <span class="keyword">if</span> curr_board[move] == <span class="string">' '</span>:</span><br><span class="line">                counter += <span class="number">1</span></span><br><span class="line">                curr_board[move] = turn</span><br><span class="line">                <span class="keyword">if</span> turn == <span class="string">'x'</span>:</span><br><span class="line">                    turn = <span class="string">'o'</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    turn = <span class="string">'x'</span></span><br><span class="line">            os.system(<span class="string">'clear'</span>)</span><br><span class="line">            print_board(curr_board)</span><br><span class="line">        choice = input(<span class="string">'再玩一局?(yes|no)'</span>)</span><br><span class="line">        begin = choice == <span class="string">'yes'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：最后这个案例来自<a href="https://item.jd.com/11943853.html" target="_blank" rel="noopener">《Python编程快速上手:让繁琐工作自动化》</a>一书（这本书对有编程基础想迅速使用Python将日常工作自动化的人来说还是不错的选择），对代码做了一点点的调整。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>14-网络编程入门</title>
    <url>/2019/10/02/tutorials/Python/14.%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="14-网络编程入门"><a href="#14-网络编程入门" class="headerlink" title="14-网络编程入门"></a>14-网络编程入门</h2><h3 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h3><p>计算机网络是独立自主的计算机互联而成的系统的总称，组建计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。今天计算机网络中的设备和计算机网络的用户已经多得不可计数，而计算机网络也可以称得上是一个“复杂巨系统”，对于这样的系统，我们不可能用一两篇文章把它讲清楚，有兴趣的读者可以自行阅读Andrew S.Tanenbaum老师的经典之作《计算机网络》或Kurose和Ross老师合著的《计算机网络:自顶向下方法》来了解计算机网络的相关知识。</p>
<h4 id="计算机网络发展史"><a href="#计算机网络发展史" class="headerlink" title="计算机网络发展史"></a>计算机网络发展史</h4><ol>
<li><p>1960s - 美国国防部ARPANET项目问世，奠定了分组交换网络的基础。</p>
<p><img src="./res/arpanet.png" alt=""></p>
</li>
<li><p>1980s - 国际标准化组织（ISO）发布OSI/RM，奠定了网络技术标准化的基础。</p>
<p><img src="./res/osimodel.png" alt=""></p>
</li>
<li><p>1990s - 英国人<a href="https://zh.wikipedia.org/wiki/%E6%8F%90%E5%A7%86%C2%B7%E6%9F%8F%E5%85%A7%E8%8C%B2-%E6%9D%8E" target="_blank" rel="noopener">蒂姆·伯纳斯-李</a>发明了图形化的浏览器，浏览器的简单易用性使得计算机网络迅速被普及。</p>
<p>在没有浏览器的年代，上网是这样的。</p>
<p><img src="./res/before-browser.jpg" alt=""></p>
<p>有了浏览器以后，上网是这样的。</p>
<p><img src="./res/after-browser.jpg" alt=""></p>
</li>
</ol>
<h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p>实现网络通信的基础是网络通信协议，这些协议通常是由<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%B7%A5%E7%A8%8B%E4%BB%BB%E5%8A%A1%E7%BB%84" target="_blank" rel="noopener">互联网工程任务组</a> （IETF）制定的。所谓“协议”就是通信计算机双方必须共同遵从的一组约定，例如怎样建立连接、怎样互相识别等，网络协议的三要素是：语法、语义和时序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西称为TCP/IP模型。与国际标准化组织发布的OSI/RM这个七层模型不同，TCP/IP是一个四层模型，也就是说，该模型将我们使用的网络从逻辑上分解为四个层次，自底向上依次是：网络接口层、网络层、传输层和应用层，如下图所示。</p>
<p><img src="./res/TCP-IP-model.png" alt=""></p>
<p>IP通常被翻译为网际协议，它服务于网络层，主要实现了寻址和路由的功能。接入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPv4地址的匮乏，我们平常在家里、办公室以及其他可以接入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是一个<a href="https://zh.wikipedia.org/zh-hans/%E5%B1%80%E5%9F%9F%E7%BD%91" target="_blank" rel="noopener">局域网（LAN）</a>中的内部IP地址，通过<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">网络地址转换（NAT）服务</a>我们也可以实现对网络的访问。计算机网络上有大量的被我们称为“<a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="noopener">路由器</a>”的网络中继设备，它们会存储转发我们发送到网络上的数据分组，让从源头发出的数据最终能够找到传送到目的地通路，这项功能就是所谓的路由。</p>
<p>TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP称为可靠的传输协议是因为TCP向调用者承诺了三件事情：</p>
<ol>
<li>数据不传丢不传错（利用握手、校验和重传机制可以实现）。</li>
<li>流量控制（通过滑动窗口匹配数据发送者和接收者之间的传输速度）。</li>
<li>拥塞控制（通过RTT时间以及对滑动窗口的控制缓解网络拥堵）。</li>
</ol>
<h4 id="网络应用模式"><a href="#网络应用模式" class="headerlink" title="网络应用模式"></a>网络应用模式</h4><ol>
<li>C/S模式和B/S模式。这里的C指的是Client（客户端），通常是一个需要安装到某个宿主操作系统上的应用程序；而B指的是Browser（浏览器），它几乎是所有图形化操作系统都默认安装了的一个应用软件；通过C或B都可以实现对S（服务器）的访问。关于二者的比较和讨论在网络上有一大堆的文章，在此我们就不再浪费笔墨了。</li>
<li>去中心化的网络应用模式。不管是B/S还是C/S都需要服务器的存在，服务器就是整个应用模式的中心，而去中心化的网络应用通常没有固定的服务器或者固定的客户端，所有应用的使用者既可以作为资源的提供者也可以作为资源的访问者。</li>
</ol>
<h3 id="基于HTTP协议的网络资源访问"><a href="#基于HTTP协议的网络资源访问" class="headerlink" title="基于HTTP协议的网络资源访问"></a>基于HTTP协议的网络资源访问</h3><h4 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h4><p>HTTP是超文本传输协议（Hyper-Text Transfer Proctol）的简称，维基百科上对HTTP的解释是：超文本传输协议是一种用于分布式、协作式和超媒体信息系统的应用层协议，它是<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2" target="_blank" rel="noopener">万维网</a>数据通信的基础，设计HTTP最初的目的是为了提供一种发布和接收<a href="https://zh.wikipedia.org/wiki/HTML" target="_blank" rel="noopener">HTML</a>页面的方法，通过HTTP或者<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">HTTPS</a>（超文本传输安全协议）请求的资源由URI（<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E8%B3%87%E6%BA%90%E6%A8%99%E8%AD%98%E7%AC%A6" target="_blank" rel="noopener">统一资源标识符</a>）来标识。关于HTTP的更多内容，我们推荐阅读阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="noopener">《HTTP 协议入门》</a>，简单的说，通过HTTP我们可以获取网络上的（基于字符的）资源，开发中经常会用到的网络API（有的地方也称之为网络数据接口）就是基于HTTP来实现数据传输的。</p>
<h4 id="JSON格式"><a href="#JSON格式" class="headerlink" title="JSON格式"></a>JSON格式</h4><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation）是一种轻量级的数据交换语言，该语言以易于让人阅读的文字（纯文本）为基础，用来传输由属性值或者序列性的值组成的数据对象。尽管JSON是最初只是Javascript中一种创建对象的字面量语法，但它在当下更是一种独立于语言的数据格式，很多编程语言都支持JSON格式数据的生成和解析，Python内置的json模块也提供了这方面的功能。由于JSON是纯文本，它和<a href="https://zh.wikipedia.org/wiki/XML" target="_blank" rel="noopener">XML</a>一样都适用于异构系统之间的数据交换，而相较于XML，JSON显得更加的轻便和优雅。下面是表达同样信息的XML和JSON，而JSON的优势是相当直观的。</p>
<p>XML的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">message</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">from</span>&gt;</span>Alice<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">to</span>&gt;</span>Bob<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">content</span>&gt;</span>Will you marry me?<span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">message</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JSON的例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    'from': 'Alice',</span><br><span class="line">    'to': 'Bob',</span><br><span class="line">    'content': 'Will you marry me?'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="requests库"><a href="#requests库" class="headerlink" title="requests库"></a>requests库</h4><p>requests是一个基于HTTP协议来使用网络的第三库，其<a href="http://cn.python-requests.org/zh_CN/latest/" target="_blank" rel="noopener">官方网站</a>有这样的一句介绍它的话：“Requests是唯一的一个<strong>非转基因</strong>的Python HTTP库，人类可以安全享用。”简单的说，使用requests库可以非常方便的使用HTTP，避免安全缺陷、冗余代码以及“重复发明轮子”（行业黑话，通常用在软件工程领域表示重新创造一个已有的或是早已被优化過的基本方法）。前面的文章中我们已经使用过这个库，下面我们还是通过requests来实现一个访问网络数据接口并从中获取美女图片下载链接然后下载美女图片到本地的例子程序，程序中使用了<a href="https://www.tianapi.com/" target="_blank" rel="noopener">天行数据</a>提供的网络API。</p>
<p>我们可以先通过pip安装requests及其依赖库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br></pre></td></tr></table></figure>

<p>如果使用PyCharm作为开发工具，可以直接在代码中书写<code>import requests</code>，然后通过代码修复功能来自动下载安装requests。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承Thread类创建自定义的线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadHanlder</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.url = url</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        filename = self.url[self.url.rfind(<span class="string">'/'</span>) + <span class="number">1</span>:]</span><br><span class="line">        resp = requests.get(self.url)</span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'/Users/Hao/'</span> + filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(resp.content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 通过requests模块的get函数获取网络资源</span></span><br><span class="line">    <span class="comment"># 下面的代码中使用了天行数据接口提供的网络API</span></span><br><span class="line">    <span class="comment"># 要使用该数据接口需要在天行数据的网站上注册</span></span><br><span class="line">    <span class="comment"># 然后用自己的Key替换掉下面代码的中APIKey即可</span></span><br><span class="line">    resp = requests.get(</span><br><span class="line">        <span class="string">'http://api.tianapi.com/meinv/?key=APIKey&amp;num=10'</span>)</span><br><span class="line">    <span class="comment"># 将服务器返回的JSON格式的数据解析为字典</span></span><br><span class="line">    data_model = resp.json()</span><br><span class="line">    <span class="keyword">for</span> mm_dict <span class="keyword">in</span> data_model[<span class="string">'newslist'</span>]:</span><br><span class="line">        url = mm_dict[<span class="string">'picUrl'</span>]</span><br><span class="line">        <span class="comment"># 通过多线程的方式实现图片下载</span></span><br><span class="line">        DownloadHanlder(url).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="基于传输层协议的套接字编程"><a href="#基于传输层协议的套接字编程" class="headerlink" title="基于传输层协议的套接字编程"></a>基于传输层协议的套接字编程</h3><p>套接字这个词对很多不了解网络编程的人来说显得非常晦涩和陌生，其实说得通俗点，套接字就是一套用<a href="https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">C语言</a>写成的应用程序开发库，主要用于实现进程间通信和网络编程，在网络应用开发中被广泛使用。在Python中也可以基于套接字来使用传输层提供的传输服务，并基于此开发自己的网络应用。实际开发中使用的套接字可以分为三类：流套接字（TCP套接字）、数据报套接字和原始套接字。</p>
<h4 id="TCP套接字"><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h4><p>所谓TCP套接字就是使用TCP协议提供的传输服务来实现网络通信的编程接口。在Python中可以通过创建socket对象并指定type属性为SOCK_STREAM来使用TCP套接字。由于一台主机可能拥有多个IP地址，而且很有可能会配置多个不同的服务，所以作为服务器端的程序，需要在创建套接字对象后将其绑定到指定的IP地址和端口上。这里的端口并不是物理设备而是对IP地址的扩展，用于区分不同的服务，例如我们通常将HTTP服务跟80端口绑定，而MySQL数据库服务默认绑定在3306端口，这样当服务器收到用户请求时就可以根据端口号来确定到底用户请求的是HTTP服务器还是数据库服务器提供的服务。端口的取值范围是0~65535，而1024以下的端口我们通常称之为“著名端口”（留给像FTP、HTTP、SMTP等“著名服务”使用的端口，有的地方也称之为“周知端口”），自定义的服务通常不使用这些端口，除非自定义的是HTTP或FTP这样的著名服务。</p>
<p>下面的代码实现了一个提供时间日期的服务器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    <span class="comment"># family=AF_INET - IPv4地址</span></span><br><span class="line">    <span class="comment"># family=AF_INET6 - IPv6地址</span></span><br><span class="line">    <span class="comment"># type=SOCK_STREAM - TCP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_DGRAM - UDP套接字</span></span><br><span class="line">    <span class="comment"># type=SOCK_RAW - 原始套接字</span></span><br><span class="line">    server = socket(family=AF_INET, type=SOCK_STREAM)</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(端口用于区分不同的服务)</span></span><br><span class="line">    <span class="comment"># 同一时间在同一个端口上只能绑定一个服务否则报错</span></span><br><span class="line">    server.bind((<span class="string">'192.168.1.2'</span>, <span class="number">6789</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    <span class="comment"># 参数512可以理解为连接队列的大小</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    print(<span class="string">'服务器启动开始监听...'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 4.通过循环接收客户端的连接并作出相应的处理(提供服务)</span></span><br><span class="line">        <span class="comment"># accept方法是一个阻塞方法如果没有客户端连接到服务器代码不会向下执行</span></span><br><span class="line">        <span class="comment"># accept方法返回一个元组其中的第一个元素是客户端对象</span></span><br><span class="line">        <span class="comment"># 第二个元素是连接到服务器的客户端的地址(由IP和端口两部分构成)</span></span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        print(str(addr) + <span class="string">'连接到了服务器.'</span>)</span><br><span class="line">        <span class="comment"># 5.发送数据</span></span><br><span class="line">        client.send(str(datetime.now()).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="comment"># 6.断开连接</span></span><br><span class="line">        client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行服务器程序后我们可以通过Windows系统的telnet来访问该服务器，结果如下图所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet 192.168.1.2 6789</span><br></pre></td></tr></table></figure>

<p><img src="./res/telnet.png" alt=""></p>
<p>当然我们也可以通过Python的程序来实现TCP客户端的功能，相较于实现服务器程序，实现客户端程序就简单多了，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1.创建套接字对象默认使用IPv4和TCP协议</span></span><br><span class="line">    client = socket()</span><br><span class="line">    <span class="comment"># 2.连接到服务器(需要指定IP地址和端口)</span></span><br><span class="line">    client.connect((<span class="string">'192.168.1.2'</span>, <span class="number">6789</span>))</span><br><span class="line">    <span class="comment"># 3.从服务器接收数据</span></span><br><span class="line">    print(client.recv(<span class="number">1024</span>).decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    client.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面的服务器并没有使用多线程或者异步I/O的处理方式，这也就意味着当服务器与一个客户端处于通信状态时，其他的客户端只能排队等待。很显然，这样的服务器并不能满足我们的需求，我们需要的服务器是能够同时接纳和处理多个用户请求的。下面我们来设计一个使用多线程技术处理多个用户请求的服务器，该服务器会向连接到服务器的客户端发送一张图片。</p>
<p>服务器端代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket, SOCK_STREAM, AF_INET</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> dumps</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 自定义线程类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">FileTransferHandler</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, cclient)</span>:</span></span><br><span class="line">            super().__init__()</span><br><span class="line">            self.cclient = cclient</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">            my_dict = &#123;&#125;</span><br><span class="line">            my_dict[<span class="string">'filename'</span>] = <span class="string">'guido.jpg'</span></span><br><span class="line">            <span class="comment"># JSON是纯文本不能携带二进制数据</span></span><br><span class="line">            <span class="comment"># 所以图片的二进制数据要处理成base64编码</span></span><br><span class="line">            my_dict[<span class="string">'filedata'</span>] = data</span><br><span class="line">            <span class="comment"># 通过dumps函数将字典处理成JSON字符串</span></span><br><span class="line">            json_str = dumps(my_dict)</span><br><span class="line">            <span class="comment"># 发送JSON字符串</span></span><br><span class="line">            self.cclient.send(json_str.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">            self.cclient.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1.创建套接字对象并指定使用哪种传输服务</span></span><br><span class="line">    server = socket()</span><br><span class="line">    <span class="comment"># 2.绑定IP地址和端口(区分不同的服务)</span></span><br><span class="line">    server.bind((<span class="string">'192.168.1.2'</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 3.开启监听 - 监听客户端连接到服务器</span></span><br><span class="line">    server.listen(<span class="number">512</span>)</span><br><span class="line">    print(<span class="string">'服务器启动开始监听...'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'guido.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将二进制数据处理成base64再解码成字符串</span></span><br><span class="line">        data = b64encode(f.read()).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        client, addr = server.accept()</span><br><span class="line">        <span class="comment"># 启动一个线程来处理客户端的请求</span></span><br><span class="line">        FileTransferHandler(client).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> json <span class="keyword">import</span> loads</span><br><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    client = socket()</span><br><span class="line">    client.connect((<span class="string">'192.168.1.2'</span>, <span class="number">5566</span>))</span><br><span class="line">    <span class="comment"># 定义一个保存二进制数据的对象</span></span><br><span class="line">    in_data = bytes()</span><br><span class="line">    <span class="comment"># 由于不知道服务器发送的数据有多大每次接收1024字节</span></span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">while</span> data:</span><br><span class="line">        <span class="comment"># 将收到的数据拼接起来</span></span><br><span class="line">        in_data += data</span><br><span class="line">        data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="comment"># 将收到的二进制数据解码成JSON字符串并转换成字典</span></span><br><span class="line">    <span class="comment"># loads函数的作用就是将JSON字符串转成字典对象</span></span><br><span class="line">    my_dict = loads(in_data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">    filename = my_dict[<span class="string">'filename'</span>]</span><br><span class="line">    filedata = my_dict[<span class="string">'filedata'</span>].encode(<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/Users/Hao/'</span> + filename, <span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="comment"># 将base64格式的数据解码成二进制数据并写入文件</span></span><br><span class="line">        f.write(b64decode(filedata))</span><br><span class="line">    print(<span class="string">'图片已保存.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在这个案例中，我们使用了JSON作为数据传输的格式（通过JSON格式对传输的数据进行了序列化和反序列化的操作），但是JSON并不能携带二进制数据，因此对图片的二进制数据进行了Base64编码的处理。Base64是一种用64个字符表示所有二进制数据的编码方式，通过将二进制数据每6位一组的方式重新组织，刚好可以使用0~9的数字、大小写字母以及“+”和“/”总共64个字符表示从<code>000000</code>到<code>111111</code>的64种状态。<a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">维基百科</a>上有关于Base64编码的详细讲解，不熟悉Base64的读者可以自行阅读。</p>
<blockquote>
<p><strong>说明</strong>：上面的代码主要为了讲解网络编程的相关内容因此并没有对异常状况进行处理，请读者自行添加异常处理代码来增强程序的健壮性。</p>
</blockquote>
<h4 id="UDP套接字"><a href="#UDP套接字" class="headerlink" title="UDP套接字"></a>UDP套接字</h4><p>传输层除了有可靠的传输协议TCP之外，还有一种非常轻便的传输协议叫做用户数据报协议，简称UDP。TCP和UDP都是提供端到端传输服务的协议，二者的差别就如同打电话和发短信的区别，后者不对传输的可靠性和可达性做出任何承诺从而避免了TCP中握手和重传的开销，所以在强调性能和而不是数据完整性的场景中（例如传输网络音视频数据），UDP可能是更好的选择。可能大家会注意到一个现象，就是在观看网络视频时，有时会出现卡顿，有时会出现花屏，这无非就是部分数据传丢或传错造成的。在Python中也可以使用UDP套接字来创建网络应用，对此我们不进行赘述，有兴趣的读者可以自行研究。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>12-进程和线程</title>
    <url>/2019/10/02/tutorials/Python/12.%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="12-进程和线程"><a href="#12-进程和线程" class="headerlink" title="12-进程和线程"></a>12-进程和线程</h2><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p>
<p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。</p>
<p><img src="./res/macos-monitor.png" alt=""></p>
<p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p>
<p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p>
<h3 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h3><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p>
<p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    download_task(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    download_task(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>下面是运行程序得到的一次运行结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了6秒</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">总共耗费了13.01秒.</span><br></pre></td></tr></table></figure>

<p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'启动下载进程，进程号[%d].'</span> % getpid())</span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">'Python从入门到住院.pdf'</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">'Peking Hot.avi'</span>, ))</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动下载进程，进程号[1530].</span><br><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">启动下载进程，进程号[1531].</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了10秒</span><br><span class="line">总共耗费了10.01秒.</span><br></pre></td></tr></table></figure>

<p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_task</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">        print(string, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Ping'</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Pong'</span>, )).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p>
<h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = Thread(target=download, args=(<span class="string">'Python从入门到住院.pdf'</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = Thread(target=download, args=(<span class="string">'Peking Hot.avi'</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.3f秒'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'开始下载%s...'</span> % self._filename)</span><br><span class="line">        time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        sleep(time_to_download)</span><br><span class="line">        print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (self._filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = DownloadTask(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = DownloadTask(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># 修改账户余额</span></span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p>
<h3 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p>
<p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p>
<p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。</p>
<p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p>
<blockquote>
<p><strong>说明：</strong>上面的内容和例子来自于<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p>
</blockquote>
<h3 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h3><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。</p>
<p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。</p>
<h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#例子1：将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"></a>例子1：将耗时间的任务放到线程中以获得更好的用户体验。</h4><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 模拟下载任务需要花费10秒钟时间</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_about</span><span class="params">()</span>:</span></span><br><span class="line">    tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskHandler</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line">            <span class="comment"># 启用下载按钮</span></span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 禁用下载按钮</span></span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        <span class="comment"># 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)</span></span><br><span class="line">        <span class="comment"># 在线程中处理耗时间的下载任务</span></span><br><span class="line">        DownloadTaskHandler(daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_about</span><span class="params">()</span>:</span></span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h4 id="例子2：使用多进程对复杂任务进行“分而治之”。"><a href="#例子2：使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="例子2：使用多进程对复杂任务进行“分而治之”。"></a>例子2：使用多进程对复杂任务进行“分而治之”。</h4><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</span><br><span class="line">        total += number</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'Execution time: %.3fs'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_handler</span><span class="params">(curr_list, result_queue)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> curr_list:</span><br><span class="line">        total += number</span><br><span class="line">    result_queue.put(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    processes = []</span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    result_queue = Queue()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 启动8个进程将数据切片后进行运算</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=task_handler,</span><br><span class="line">                    args=(number_list[index:index + <span class="number">12500000</span>], result_queue))</span><br><span class="line">        index += <span class="number">12500000</span></span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="comment"># 开始记录所有进程执行完成花费的时间</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># 合并执行结果</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        total += result_queue.get()</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'Execution time: '</span>, (end - start), <span class="string">'s'</span>, sep=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux in general</title>
    <url>/2019/10/02/tutorials/Linux/Linux_general/</url>
    <content><![CDATA[<h2 id="玩转Linux操作系统"><a href="#玩转Linux操作系统" class="headerlink" title="玩转Linux操作系统"></a>玩转Linux操作系统</h2><blockquote>
<p>本文中对Linux命令的讲解都是基于名为CentOS的Linux发行版本，不同的Linux发行版本在Shell命令和工具程序上会有一些差别，但是这些差别是很小的。</p>
</blockquote>
<h3 id="操作系统发展史"><a href="#操作系统发展史" class="headerlink" title="操作系统发展史"></a>操作系统发展史</h3><p>只有硬件没有软件的计算机系统被称之为“裸机”，我们很难用“裸机”来完成计算机日常的工作（如存储和运算），所以必须用特定的软件来控制硬件的工作。最靠近计算机硬件的软件是系统软件，其中最为重要的就是“操作系统”。“操作系统”是控制和管理整个计算机系统的硬件和软件资源，合理的分配资源和调配任务，为系统用户和其他软件提供接口和环境的程序的集合。</p>
<h4 id="没有操作系统（手工操作）"><a href="#没有操作系统（手工操作）" class="headerlink" title="没有操作系统（手工操作）"></a>没有操作系统（手工操作）</h4><p>在计算机诞生之初没有操作系统的年代，人们先把程序纸带（或卡片）装上计算机，然后启动输入机把程序和送入计算机，接着通过控制台开关启动程序运行。当程序执行完毕，打印机输出计算的结果，用户卸下并取走纸带（或卡片）。第二个用户上机，重复同样的步骤。在整个过程中用户独占机器，CPU等待手工操作，资源利用率极低。下图是IBM生产的书写Fortran程序的80栏打孔卡，当然这个已经是比较先进的打孔卡了。</p>
<p><img src="ibm-col80-punched-card.png" alt=""></p>
<h4 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h4><p>首先启动计算机上的一个监督程序，在监督程序的控制下，计算机能够自动的、成批的处理一个或多个用户的作业。完成一批作业后，监督程度又从输入机读取作业存入磁带机。按照上面的步骤重复处理任务。监督程序不停的处理各个作业，实现了作业的自动转接，减少了作业的建立时间和手工操作时间，提高了计算机资源的利用率。 批处理系统又可以分为单道批处理系统、多道批处理系统、联机批处理系统、脱机批处理系统。</p>
<h4 id="分时系统和实时系统"><a href="#分时系统和实时系统" class="headerlink" title="分时系统和实时系统"></a>分时系统和实时系统</h4><p>分时系统是把处理器的运行时间分成很短的时间片，按时间片轮流把处理机分配给各联机作业使用。 若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时中断，把处理机让给另一作业使用，等待下一轮调度时再继续其运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉是他独占了一台计算机。而每个用户可以通过自己的终端向系统发出各种操作控制命令，在充分的人机交互情况下，完成作业的运行。为了解决分时系统不能及时响应用户指令的情况，又出现了能够在在严格的时间范围内完成事件处理，及时响应随机外部事件的实时系统。</p>
<h4 id="通用操作系统"><a href="#通用操作系统" class="headerlink" title="通用操作系统"></a>通用操作系统</h4><ol>
<li><p>1960s：IBM的System/360系列的机器有了统一的操作系统OS/360。</p>
</li>
<li><p>1965年：AT&amp;T的贝尔实验室加入GE和MIT的合作计划开始开发MULTICS。</p>
</li>
<li><p>1969年：Ken Tompson为了玩“Space Travel”游戏用汇编语言在PDP-7上开发了Unics。</p>
<p><img src="Ken-Thompson.png" alt=""></p>
<p><img src="pdp-7.png" alt=""></p>
</li>
<li><p>1970年~1971年：Ken Tompson和Dennis Ritchie用B语言在PDP-11上重写了Unics，并在Brian Kernighan的建议下将其更名为Unix。</p>
<p><img src="ken-and-dennis-pdp-11.png" alt=""></p>
</li>
<li><p>1972年~1973年：Dennis Ritchie发明了C语言来取代可移植性较差的B语言，并开启了用C语言重写Unix的工作。</p>
<p><img src="dennis-ritchie.png" alt=""></p>
</li>
<li><p>1974年：Unix推出了里程碑意义的第5版，几乎完全用C语言来实现。</p>
</li>
<li><p>1979年：从Unix第7版开始，AT&amp;T发布新的使用条款，将Unix私有化。</p>
</li>
<li><p>1987年：Andrew S. Tanenbaum教授为了能在课堂上教授学生操作系统运作的细节，决定在不使用任何AT&amp;T的源代码前提下，自行开发与Unix兼容的操作系统，以避免版权上的争议并将其命名为Minix。</p>
<p><img src="andrew-tanenbaum.png" alt=""></p>
</li>
<li><p>1991年：Linus Torvalds就读于芬兰赫尔辛基大学期间，尝试在Minix上做一些开发工作，但因为Minix只是作为教学用途的操作系统，功能并不强大，为了方便在学校的主机的新闻组和邮件系统中读写和下载文件，Linus编写了磁盘驱动程序和文件系统，这些成为了Linux系统内核的雏形。</p>
<p><img src="linus-torvalds.png" alt=""></p>
</li>
</ol>
<p>下图是Unix操作系统家族的图谱。</p>
<p><img src="history-of-unix.png" alt=""></p>
<h3 id="Linux概述"><a href="#Linux概述" class="headerlink" title="Linux概述"></a>Linux概述</h3><p>Linux是一个通用操作系统。一个操作系统要负责任务调度、内存分配、处理外围设备I/O等操作。操作系统通常由内核（运行其他程序，管理像磁盘、打印机等硬件设备的核心程序）和系统程序（设备驱动、底层库、shell、服务程序等）两部分组成。</p>
<p>Linux内核是芬兰人Linus Torvalds开发的，于1991年9月发布。而Linux操作系统作为Internet时代的产物，它是由全世界许多开发者共同合作开发的，是一个自由的操作系统（注意自由和免费并不是同一个概念，想了解二者的差别可以<a href="https://www.debian.org/intro/free" target="_blank" rel="noopener">点击这里</a>）。</p>
<h3 id="Linux系统优点"><a href="#Linux系统优点" class="headerlink" title="Linux系统优点"></a>Linux系统优点</h3><ol>
<li>通用操作系统，不跟特定的硬件绑定。</li>
<li>用C语言编写，有可移植性，有内核编程接口。</li>
<li>支持多用户和多任务，支持安全的分层文件系统。</li>
<li>大量的实用程序，完善的网络功能以及强大的支持文档。</li>
<li>可靠的安全性和良好的稳定性，对开发者更友好。</li>
</ol>
<h3 id="Linux系统发行版本"><a href="#Linux系统发行版本" class="headerlink" title="Linux系统发行版本"></a>Linux系统发行版本</h3><ol>
<li><a href="https://www.redhat.com/en" target="_blank" rel="noopener">Redhat</a></li>
<li><a href="https://www.ubuntu.com/" target="_blank" rel="noopener">Ubuntu</a></li>
<li><a href="https://www.centos.org/" target="_blank" rel="noopener">CentOS</a></li>
<li><a href="https://getfedora.org/" target="_blank" rel="noopener">Fedora</a></li>
<li><a href="https://www.debian.org/" target="_blank" rel="noopener">Debian</a></li>
<li><a href="https://www.opensuse.org/" target="_blank" rel="noopener">openSUSE</a></li>
<li><a href="https://www.archlinux.org/" target="_blank" rel="noopener">Arch</a></li>
</ol>
<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><p>Linux系统的命令通常都是如下所示的格式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令名称 [命名参数] [命令对象]</span><br></pre></td></tr></table></figure>

<ol>
<li><p>获取登录信息 - <strong>w</strong> / <strong>who</strong> / <strong>last</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# w</span><br><span class="line"> 23:31:16 up 12:16,  2 users,  load average: 0.00, 0.01, 0.05</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    182.139.66.250   23:03    4.00s  0.02s  0.00s w</span><br><span class="line">jackfrue pts/1    182.139.66.250   23:26    3:56   0.00s  0.00s -bash</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# who</span><br><span class="line">root     pts/0        2018-04-12 23:03 (182.139.66.250)</span><br><span class="line">jackfrued pts/1        2018-04-12 23:26 (182.139.66.250)</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# who am i</span><br><span class="line">root     pts/0        2018-04-12 23:03 (182.139.66.250)</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看自己使用的Shell - <strong>ps</strong>。</p>
<p>Shell也被称为“壳”，它是用户与内核交流的翻译官，简单的说就是人与计算机交互的接口。目前很多Linux系统默认的Shell都是bash（<u>B</u>ourne <u>A</u>gain <u>SH</u>ell），因为它可以使用Tab键进行命令补全、可以保存历史命令、可以方便的配置环境变量以及执行批处理操作等。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 3531 pts/0    00:00:00 bash</span><br><span class="line"> 3553 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命令的说明 - <strong>whatis</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# whatis ps</span><br><span class="line">ps (1)        - report a snapshot of the current processes.</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# whatis python</span><br><span class="line">python (1)    - an interpreted, interactive, object-oriented programming language</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看命令的位置 - <strong>which</strong> / <strong>whereis</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# whereis ps</span><br><span class="line">ps: /usr/bin/ps /usr/share/man/man1/ps.1.gz</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# whereis python</span><br><span class="line">python: /usr/bin/python /usr/bin/python2.7 /usr/lib/python2.7 /usr/lib64/python2.7 /etc/python /usr/include/python2.7 /usr/share/man/man1/python.1.gz</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# which ps</span><br><span class="line">/usr/bin/ps</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# which python</span><br><span class="line">/usr/bin/python</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看帮助文档 - <strong>man</strong> / <strong>info</strong> / <strong>apropos</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# ps --help</span><br><span class="line">Usage:</span><br><span class="line"> ps [options]</span><br><span class="line"> Try 'ps --help &lt;simple|list|output|threads|misc|all&gt;'</span><br><span class="line">  or 'ps --help &lt;s|l|o|t|m|a&gt;'</span><br><span class="line"> for additional help text.</span><br><span class="line">For more details see ps(1).</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# man ps</span><br><span class="line">PS(1)                                User Commands                                PS(1)</span><br><span class="line">NAME</span><br><span class="line">       ps - report a snapshot of the current processes.</span><br><span class="line">SYNOPSIS</span><br><span class="line">       ps [options]</span><br><span class="line">DESCRIPTION</span><br><span class="line">...</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# info ps</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换用户 - <strong>su</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# su hellokitty</span><br><span class="line">[hellokitty@izwz97tbgo9lkabnat2lo8z root]$</span><br></pre></td></tr></table></figure>
</li>
<li><p>以管理员身份执行命令 - <strong>sudo</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[jackfrued@izwz97tbgo9lkabnat2lo8z ~]$ ls /root</span><br><span class="line">ls: cannot open directory /root: Permission denied</span><br><span class="line">[jackfrued@izwz97tbgo9lkabnat2lo8z ~]$ sudo ls /root</span><br><span class="line">[sudo] password for jackfrued:</span><br><span class="line">calendar.py  code  error.txt  hehe  hello.c  index.html  myconf  result.txt</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>说明</strong>：如果希望用户能够以管理员身份执行命令，用户必须被添加到sudoers名单中，该文件在 <code>/etc</code>目录下。</p>
</blockquote>
</li>
<li><p>登入登出相关 - <strong>logout</strong> / <strong>exit</strong> / <strong>adduser</strong> / <strong>userdel</strong> / <strong>passwd</strong> / <strong>ssh</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# adduser hellokitty</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# passwd hellokitty</span><br><span class="line">Changing password for user jackfrued.</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# ssh hellokitty@1.2.3.4</span><br><span class="line">hellokitty@1.2.3.4's password:</span><br><span class="line">Last login: Thu Apr 12 23:05:32 2018 from 10.12.14.16</span><br><span class="line">[hellokitty@izwz97tbgo9lkabnat2lo8z ~]$ logout</span><br><span class="line">Connection to 1.2.3.4 closed.</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]#</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看系统和主机名 - <strong>uname</strong> / <strong>hostname</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# uname</span><br><span class="line">Linux</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# hostname</span><br><span class="line">izwz97tbgo9lkabnat2lo8z</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启和关机 - <strong>reboot</strong> / <strong>init 6</strong> / <strong>shutdown</strong> / <strong>init 0</strong>。</p>
</li>
<li><p>查看历史命令 - <strong>history</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# history</span><br><span class="line">...</span><br><span class="line">452  ls</span><br><span class="line">453  cd Python-3.6.5/</span><br><span class="line">454  clear</span><br><span class="line">455  history</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# !454</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：查看到历史命令之后，可以用<code>!历史命令编号</code>来重新执行该命令；通过<code>history -c</code>可以清除历史命令。</p>
</blockquote>
</li>
</ol>
<h3 id="实用程序"><a href="#实用程序" class="headerlink" title="实用程序"></a>实用程序</h3><h4 id="文件和文件夹操作"><a href="#文件和文件夹操作" class="headerlink" title="文件和文件夹操作"></a>文件和文件夹操作</h4><ol>
<li><p>创建/删除目录 - <strong>mkdir</strong> / <strong>rmdir</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mkdir abc</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mkdir -p xyz/abc</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rmdir abc</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建/删除文件 - <strong>touch</strong> / <strong>rm</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# touch readme.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# touch error.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rm error.txt</span><br><span class="line">rm: remove regular empty file ‘error.txt’? y</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rm -rf xyz</span><br></pre></td></tr></table></figure>

<ul>
<li>touch命令用于创建空白文件或修改文件时间。在Linux系统中一个文件有三种时间：<ul>
<li>更改内容的时间 - mtime。</li>
<li>更改权限的时间 - ctime。</li>
<li>最后访问时间 - atime。</li>
</ul>
</li>
<li>rm的几个重要参数：<ul>
<li>-i：交互式删除，每个删除项都会进行询问。</li>
<li>-r：删除目录并递归的删除目录中的文件和目录。</li>
<li>-f：强制删除，忽略不存在的文件，没有任何提示。</li>
</ul>
</li>
</ul>
</li>
<li><p>切换和查看当前工作目录 - <strong>cd</strong> / <strong>pwd</strong>。</p>
<blockquote>
<p>说明：<code>cd</code>命令后面可以跟相对路径（以当前路径作为参照）或绝对路径（以<code>/</code>开头）来切换到指定的目录，也可以用<code>cd ..</code>来返回上一级目录。</p>
</blockquote>
</li>
<li><p>查看目录内容 - <strong>ls</strong>。</p>
<ul>
<li>-l：以长格式查看文件和目录。</li>
<li>-a：显示以点开头的文件和目录（隐藏文件）。</li>
<li>-R：遇到目录要进行递归展开（继续列出目录下面的文件和目录）。</li>
<li>-d：只列出目录，不列出其他内容。</li>
<li>-S/-t：按大小/时间排序。</li>
</ul>
</li>
<li><p>查看文件内容 - <strong>cat</strong> / <strong>head</strong> / <strong>tail</strong> / <strong>more</strong> / <strong>less</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://www.sohu.com/ -O sohu.html</span><br><span class="line">--2018-06-20 18:42:34--  http://www.sohu.com/</span><br><span class="line">Resolving www.sohu.com (www.sohu.com)... 14.18.240.6</span><br><span class="line">Connecting to www.sohu.com (www.sohu.com)|14.18.240.6|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 212527 (208K) [text/html]</span><br><span class="line">Saving to: ‘sohu.html’</span><br><span class="line"><span class="meta">100%</span><span class="bash">[==================================================&gt;] 212,527     --.-K/s   <span class="keyword">in</span> 0.03s</span></span><br><span class="line">2018-06-20 18:42:34 (7.48 MB/s) - ‘sohu.html’ saved [212527/212527]</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sohu.html</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# head -10 sohu.html</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;搜狐&lt;/title&gt;</span><br><span class="line">&lt;meta name="Keywords" content="搜狐,门户网站,新媒体,网络媒体,新闻,财经,体育,娱乐,时尚,汽车,房产,科技,图片,论坛,微博,博客,视频,电影,电视剧"/&gt;</span><br><span class="line">&lt;meta name="Description" content="搜狐网为用户提供24小时不间断的最新资讯，及搜索、邮件等网络服务。内容包括全球热点事件、突发新闻、时事评论、热播影视剧、体育赛事、行业动态、生活服务信息，以及论坛、博客、微博、我的搜狐等互动空间。" /&gt;</span><br><span class="line">&lt;meta name="shenma-site-verification" content="1237e4d02a3d8d73e96cbd97b699e9c3_1504254750"&gt;</span><br><span class="line">&lt;meta charset="utf-8"/&gt;</span><br><span class="line">&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"/&gt;</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tail -2 sohu.html</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# less sohu.html</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat -n sohu.html | more</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝/移动文件 - <strong>cp</strong> / <strong>mv</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mkdir backup</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cp sohu.html backup/</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cd backup</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z backup]# ls</span><br><span class="line">sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z backup]# mv sohu.html sohu_index.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z backup]# ls</span><br><span class="line">sohu_index.html</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找文件和查找内容 - <strong>find</strong> / <strong>grep</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find / -name "*.html"</span><br><span class="line">/root/sohu.html</span><br><span class="line">/root/backup/sohu_index.html</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# find . -atime 7 -type f -print</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -size +2k</span><br><span class="line">[root@izwz97tbgo9lkabnat2lo8z ~]# find . -type f -name "*.swp" -delete</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep "&lt;script&gt;" sohu.html -n</span><br><span class="line">20:&lt;script&gt;</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# grep -E \&lt;\/?script.*\&gt; sohu.html -n</span><br><span class="line">20:&lt;script&gt;</span><br><span class="line">22:&lt;/script&gt;</span><br><span class="line">24:&lt;script src="//statics.itc.cn/web/v3/static/js/es5-shim-08e41cfc3e.min.js"&gt;&lt;/script&gt;</span><br><span class="line">25:&lt;script src="//statics.itc.cn/web/v3/static/js/es5-sham-1d5fa1124b.min.js"&gt;&lt;/script&gt;</span><br><span class="line">26:&lt;script src="//statics.itc.cn/web/v3/static/js/html5shiv-21fc8c2ba6.js"&gt;&lt;/script&gt;</span><br><span class="line">29:&lt;script type="text/javascript"&gt;</span><br><span class="line">52:&lt;/script&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：<code>grep</code>在搜索字符串时可以使用正则表达式，如果需要使用正则表达式可以用<code>grep -E</code>或者直接使用<code>egrep</code>。</p>
</blockquote>
</li>
<li><p>链接 - <strong>ln</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html</span><br><span class="line">-rw-r--r-- 1 root root 212131 Jun 20 19:15 sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html</span><br><span class="line">-rw-r--r-- 2 root root 212131 Jun 20 19:15 sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln /root/sohu.html /root/backup/sohu_backup2</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sohu.html</span><br><span class="line">-rw-r--r-- 3 root root 212131 Jun 20 19:15 sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /etc/centos-release sysinfo</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l sysinfo</span><br><span class="line">lrwxrwxrwx 1 root root 19 Jun 20 19:21 sysinfo -&gt; /etc/centos-release</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat sysinfo</span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat /etc/centos-release</span><br><span class="line">CentOS Linux release 7.4.1708 (Core)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：链接可以分为硬链接和软链接（符号链接）。硬链接可以认为是一个指向文件数据的指针，就像Python中对象的引用计数，每添加一个硬链接，文件的对应链接数就增加1，只有当文件的链接数为0时，文件所对应的存储空间才有可能被其他文件覆盖。我们平常删除文件时其实并没有删除硬盘上的数据，我们删除的只是一个指针，或者说是数据的一条使用记录，所以类似于“文件粉碎机”之类的软件在“粉碎”文件时除了删除文件指针，还会在文件对应的存储区域填入数据来保证文件无法再恢复。软链接类似于Windows系统下的快捷方式，当软链接链接的文件被删除时，软链接也就失效了。</p>
</blockquote>
</li>
<li><p>压缩/解压缩和归档/解归档 - <strong>gzip</strong> / <strong>gunzip</strong> / <strong>xz</strong> / <strong>tar</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class="line">--2018-06-20 19:29:59--  http://download.redis.io/releases/redis-4.0.10.tar.gz</span><br><span class="line">Resolving download.redis.io (download.redis.io)... 109.74.203.151</span><br><span class="line">Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 1738465 (1.7M) [application/x-gzip]</span><br><span class="line">Saving to: ‘redis-4.0.10.tar.gz’</span><br><span class="line"><span class="meta">100%</span><span class="bash">[==================================================&gt;] 1,738,465   70.1KB/s   <span class="keyword">in</span> 74s</span></span><br><span class="line">2018-06-20 19:31:14 (22.9 KB/s) - ‘redis-4.0.10.tar.gz’ saved [1738465/1738465]</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*</span><br><span class="line">redis-4.0.10.tar.gz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-4.0.10.tar.gz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*</span><br><span class="line">redis-4.0.10.tar</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-4.0.10.tar</span><br><span class="line">redis-4.0.10/</span><br><span class="line">redis-4.0.10/.gitignore</span><br><span class="line">redis-4.0.10/00-RELEASENOTES</span><br><span class="line">redis-4.0.10/BUGS</span><br><span class="line">redis-4.0.10/CONTRIBUTING</span><br><span class="line">redis-4.0.10/COPYING</span><br><span class="line">redis-4.0.10/INSTALL</span><br><span class="line">redis-4.0.10/MANIFESTO</span><br><span class="line">redis-4.0.10/Makefile</span><br><span class="line">redis-4.0.10/README.md</span><br><span class="line">redis-4.0.10/deps/</span><br><span class="line">redis-4.0.10/deps/Makefile</span><br><span class="line">redis-4.0.10/deps/README.md</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls redis*</span><br><span class="line">redis-4.0.10.tar</span><br><span class="line">redis-4.0.10:</span><br><span class="line">00-RELEASENOTES  COPYING  Makefile   redis.conf       runtest-sentinel  tests</span><br><span class="line">BUGS             deps     MANIFESTO  runtest          sentinel.conf     utils</span><br><span class="line">CONTRIBUTING     INSTALL  README.md  runtest-cluster  src</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他工具 - <strong>sort</strong> / <strong>uniq</strong> / <strong>diff</strong> / <strong>tr</strong> / <strong>cut</strong> / <strong>paste</strong> / <strong>file</strong> / <strong>wc</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat foo.txt</span><br><span class="line">grape</span><br><span class="line">apple</span><br><span class="line">pitaya</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat bar.txt</span><br><span class="line">100</span><br><span class="line">200</span><br><span class="line">300</span><br><span class="line">400</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# paste foo.txt bar.txt</span><br><span class="line">grape   100</span><br><span class="line">apple   200</span><br><span class="line">pitaya  300</span><br><span class="line">        400</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# paste foo.txt bar.txt &gt; hello.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cut -b 4-8 hello.txt</span><br><span class="line">pe      10</span><br><span class="line">le      20</span><br><span class="line">aya     3</span><br><span class="line">0</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat hello.txt | tr '\t' ','</span><br><span class="line">grape,100</span><br><span class="line">apple,200</span><br><span class="line">pitaya,300</span><br><span class="line">,400</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget https://www.baidu.com/img/bd_logo1.png</span><br><span class="line">--2018-06-20 18:46:53--  https://www.baidu.com/img/bd_logo1.png</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 220.181.111.188, 220.181.112.244</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|220.181.111.188|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 7877 (7.7K) [image/png]</span><br><span class="line">Saving to: ‘bd_logo1.png’</span><br><span class="line"><span class="meta">100%</span><span class="bash">[==================================================&gt;] 7,877       --.-K/s   <span class="keyword">in</span> 0s</span></span><br><span class="line">2018-06-20 18:46:53 (118 MB/s) - ‘bd_logo1.png’ saved [7877/7877][root@iZwz97tbgo9lkabnat2lo8Z ~]# file bd_logo1.png</span><br><span class="line">bd_logo1.png: PNG image data, 540 x 258, 8-bit colormap, non-interlaced</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wc sohu.html</span><br><span class="line">  2979   6355 212527 sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wc -l sohu.html</span><br><span class="line">2979 sohu.html</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="管道和重定向"><a href="#管道和重定向" class="headerlink" title="管道和重定向"></a>管道和重定向</h4><ol>
<li><p>管道的使用 - <strong>|</strong>。</p>
<p>例子：查找当前目录下文件个数。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# find ./ | wc -l</span><br><span class="line">6152</span><br></pre></td></tr></table></figure>

<p>例子：列出当前路径下的文件和文件夹，给每一项加一个编号。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls | cat -n</span><br><span class="line">     1  dump.rdb</span><br><span class="line">     2  mongodb-3.6.5</span><br><span class="line">     3  Python-3.6.5</span><br><span class="line">     4  redis-3.2.11</span><br><span class="line">     5  redis.conf</span><br></pre></td></tr></table></figure>

<p>例子：查找record.log中包含AAA，但不包含BBB的记录的总数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat record.log | grep AAA | grep -v BBB | wc -l</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出重定向和错误重定向 - <strong>&gt;</strong> / <strong>&gt;&gt;</strong> / <strong>2&gt;</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat readme.txt</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">grape</span><br><span class="line">apple</span><br><span class="line">grape</span><br><span class="line">watermelon</span><br><span class="line">pear</span><br><span class="line">pitaya</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat readme.txt | sort | uniq &gt; result.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cat result.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">grape</span><br><span class="line">pear</span><br><span class="line">pitaya</span><br><span class="line">watermelon</span><br></pre></td></tr></table></figure>
</li>
<li><p>输入重定向 - <strong>&lt;</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# echo 'hello, world!' &gt; hello.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wall &lt; hello.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]#</span><br><span class="line">Broadcast message from root@iZwz97tbgo9lkabnat2lo8Z (Wed Jun 20 19:43:05 2018):</span><br><span class="line">hello, world!</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# echo 'I will show you some code.' &gt;&gt; hello.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wall &lt; hello.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]#</span><br><span class="line">Broadcast message from root@iZwz97tbgo9lkabnat2lo8Z (Wed Jun 20 19:43:55 2018):</span><br><span class="line">hello, world!</span><br><span class="line">I will show you some code.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><ol>
<li><p><strong>alias</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# alias ll='ls -l'</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# alias frm='rm -rf'</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ll</span><br><span class="line">...</span><br><span class="line">drwxr-xr-x  2 root       root   4096 Jun 20 12:52 abc</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# frm abc</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>unalias</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# unalias frm</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# frm sohu.html</span><br><span class="line">-bash: frm: command not found</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="其他程序"><a href="#其他程序" class="headerlink" title="其他程序"></a>其他程序</h4><ol>
<li><p>时间和日期 - <strong>date</strong> / <strong>cal</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# date</span><br><span class="line">Wed Jun 20 12:53:19 CST 2018</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal</span><br><span class="line">      June 2018</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">                1  2</span><br><span class="line"> 3  4  5  6  7  8  9</span><br><span class="line">10 11 12 13 14 15 16</span><br><span class="line">17 18 19 20 21 22 23</span><br><span class="line">24 25 26 27 28 29 30</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cal 5 2017</span><br><span class="line">      May 2017</span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">    1  2  3  4  5  6</span><br><span class="line"> 7  8  9 10 11 12 13</span><br><span class="line">14 15 16 17 18 19 20</span><br><span class="line">21 22 23 24 25 26 27</span><br><span class="line">28 29 30 31</span><br></pre></td></tr></table></figure>
</li>
<li><p>录制操作脚本 - <strong>script</strong>。</p>
</li>
<li><p>给用户发送消息 - <strong>mesg</strong> / <strong>write</strong> / <strong>wall</strong> / <strong>mail</strong>。</p>
</li>
</ol>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><h4 id="文件和路径"><a href="#文件和路径" class="headerlink" title="文件和路径"></a>文件和路径</h4><ol>
<li>命名规则：文件名的最大长度与文件系统类型有关，一般情况下，文件名不应该超过255个字符，虽然绝大多数的字符都可以用于文件名，但是最好使用英文大小写字母、数字、下划线、点这样的符号。文件名中虽然可以使用空格，但应该尽可能避免使用空格，否则在输入文件名时需要用将文件名放在双引号中或者通过<code>\</code>对空格进行转义。</li>
<li>扩展名：在Linux系统下文件的扩展名是可选的，但是使用扩展名有助于对文件内容的理解。有些应用程序要通过扩展名来识别文件，但是更多的应用程序并不依赖文件的扩展名，就像<code>file</code>命令在识别文件时并不是依据扩展名来判定文件的类型。</li>
<li>隐藏文件：以点开头的文件在Linux系统中是隐藏文件（不可见文件）。</li>
</ol>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><ol>
<li>/bin - 基本命令的二进制文件。</li>
<li>/boot - 引导加载程序的静态文件。</li>
<li>/dev - 设备文件。</li>
<li><strong>/etc</strong> - 配置文件。</li>
<li>/home - 普通用户主目录的父目录。</li>
<li>/lib - 共享库文件。</li>
<li>/lib64 - 共享64位库文件。</li>
<li>/lost+found - 存放未链接文件。</li>
<li>/media - 自动识别设备的挂载目录。</li>
<li>/mnt - 临时挂载文件系统的挂载点。</li>
<li>/opt - 可选插件软件包安装位置。</li>
<li>/proc -  内核和进程信息。</li>
<li><strong>/root</strong> - 超级管理员用户主目录。</li>
<li>/run - 存放系统运行时需要的东西。</li>
<li>/sbin - 超级用户的二进制文件。</li>
<li>/sys - 设备的伪文件系统。</li>
<li>/tmp - 临时文件夹。</li>
<li><strong>/usr</strong> - 用户应用目录。</li>
<li>/var - 变量数据目录。</li>
</ol>
<h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><ol>
<li><p><strong>chmod</strong> - 改变文件模式比特。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# chmod g+w,o+w sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l</span><br><span class="line">...</span><br><span class="line">-rw-rw-rw-  1 root       root 211878 Jun 19 16:06 sohu.html</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# chmod 644 sohu.html</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 root       root 211878 Jun 19 16:06 sohu.html</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：通过上面的例子可以看出，用<code>chmod</code>改变文件模式比特有两种方式：一种是字符设定法，另一种是数字设定法。除了<code>chmod</code>之外，可以通过<code>umask</code>来设定哪些权限将在新文件的默认权限中被删除。</p>
</blockquote>
<p>长格式查看目录或文件时显示结果及其对应权限的数值如下表所示。</p>
<p><img src="file-mode.png" alt=""></p>
</li>
<li><p><strong>chown</strong> - 改变文件所有者。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 root root     54 Jun 20 10:06 readme.txt</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# chown hellokitty readme.txt</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ls -l</span><br><span class="line">...</span><br><span class="line">-rw-r--r--  1 hellokitty root     54 Jun 20 10:06 readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h4><ol>
<li><p>列出文件系统的磁盘使用状况 - <strong>df</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1        40G  5.0G   33G  14% /</span><br><span class="line">devtmpfs        486M     0  486M   0% /dev</span><br><span class="line">tmpfs           497M     0  497M   0% /dev/shm</span><br><span class="line">tmpfs           497M  356K  496M   1% /run</span><br><span class="line">tmpfs           497M     0  497M   0% /sys/fs/cgroup</span><br><span class="line">tmpfs           100M     0  100M   0% /run/user/0</span><br></pre></td></tr></table></figure>
</li>
<li><p>磁盘分区表操作 - <strong>fdisk</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# fdisk -l</span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000a42f4</span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83884031    41940992   83  Linux</span><br><span class="line">Disk /dev/vdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure>
</li>
<li><p>格式化文件系统 - <strong>mkfs</strong>。</p>
</li>
<li><p>文件系统检查 - <strong>fsck</strong>。</p>
</li>
<li><p>挂载/卸载 - <strong>mount</strong> / <strong>umount</strong>。</p>
</li>
</ol>
<h3 id="编辑器-vim"><a href="#编辑器-vim" class="headerlink" title="编辑器 - vim"></a>编辑器 - vim</h3><ol>
<li><p>启动vim。可以通过<code>vi</code>或<code>vim</code>命令来启动vim，启动时可以指定文件名来打开一个文件，如果没有指定文件名，也可以在保存的时候指定文件名。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# vim guess.py</span><br></pre></td></tr></table></figure>
</li>
<li><p>命令模式、编辑模式和末行模式：启动vim进入的是命令模式（也称为Normal模式），在命令模式下输入英文字母<code>i</code>会进入编辑模式（Insert模式），屏幕下方出现<code>-- INSERT --</code>提示；在编辑模式下按下<code>Esc</code>会回到命令模式，此时如果输入英文<code>:</code>会进入末行模式，在末行模式下输入<code>q!</code>可以在不保存当前工作的情况下强行退出vim；在命令模式下输入<code>v</code>会进入可视模式（Visual模式），可以用光标选择一个区域再完成对应的操作。</p>
</li>
<li><p>保存和退出vim：在命令模式下输入<code>:</code> 进入末行模式，输入<code>wq</code>可以实现保存退出；如果想放弃编辑的内容输入<code>q!</code>强行退出，这一点刚才已经提到过了；在命令模式下也可以直接输入<code>ZZ</code>实现保存退出。如果只想保存文件不退出，那么可以在末行模式下输入<code>w</code>；可以在<code>w</code>后面输入空格再指定要保存的文件名。</p>
</li>
<li><p>光标操作。</p>
<ul>
<li>在命令模式下可以通过<code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>来控制光标向左、下、上、右的方向移动，可以在字母前输入数字来表示移动的距离，例如：<code>10h</code>表示向左移动10个字符。</li>
<li>在命令模式下可以通过<code>Ctrl+y</code>和<code>Ctrl+e</code>来实现向上、向下滚动一行文本的操作，可以通过<code>Ctrl+f</code>和<code>Ctrl+b</code>来实现向前和向后翻页的操作。</li>
<li>在命令模式下可以通过输入英文字母<code>G</code>将光标移到文件的末尾，可以通过<code>gg</code>将光标移到文件的开始，也可以通过在<code>G</code>前输入数字来将光标移动到指定的行。</li>
</ul>
</li>
<li><p>文本操作。</p>
<ul>
<li>删除：在命令模式下可以用<code>dd</code>来删除整行；可以在<code>dd</code>前加数字来指定删除的行数；可以用<code>d$</code>来实现删除从光标处删到行尾的操作，也可以通过<code>d0</code>来实现从光标处删到行首的操作；如果想删除一个单词，可以使用<code>dw</code>；如果要删除全文，可以在输入<code>:%d</code>（其中<code>:</code>用来从命令模式进入末行模式）。</li>
<li>复制和粘贴：在命令模式下可以用<code>yy</code>来复制整行；可以在<code>yy</code>前加数字来指定复制的行数；可以通过<code>p</code>将复制的内容粘贴到光标所在的地方。</li>
<li>撤销和恢复：在命令模式下输入<code>u</code>可以撤销之前的操作；通过<code>Ctrl+r</code>可以恢复被撤销的操作。</li>
<li>对内容进行排序：在命令模式下输入<code>%!sort</code>。</li>
</ul>
</li>
<li><p>查找和替换。</p>
<ul>
<li>查找操作需要输入<code>/</code>进入末行模式并提供正则表达式来匹配与之对应的内容，例如：<code>/doc.*\.</code>，输入<code>n</code>来向前搜索，也可以输入<code>N</code>来向后搜索。</li>
<li>替换操作需要输入<code>:</code>进入末行模式并指定搜索的范围、正则表达式以及替换后的内容和匹配选项，例如：<code>:1,$s/doc.*/hello/gice</code>，其中：<ul>
<li><code>g</code> - global：全局匹配。</li>
<li><code>i</code> - ignore case：忽略大小写匹配。</li>
<li><code>c</code> - confirm：替换时需要确认。</li>
<li><code>e</code> - error：忽略错误。</li>
</ul>
</li>
</ul>
</li>
<li><p>参数设定：在输入<code>:</code>进入末行模式后可以对vim进行设定。</p>
<ul>
<li><p>设置Tab键的空格数：<code>set ts=4</code></p>
</li>
<li><p>设置显示/不显示行号：<code>set nu</code> / <code>set nonu</code></p>
</li>
<li><p>设置启用/关闭高亮语法：<code>syntax on</code> / <code>syntax off</code></p>
</li>
<li><p>设置显示标尺（光标所在的行和列）： <code>set ruler</code></p>
</li>
<li><p>设置启用/关闭搜索结果高亮：<code>set hls</code> / <code>set nohls</code></p>
<blockquote>
<p>说明：如果希望上面的这些设定在每次启动vim时都能生效，需要将这些设定写到用户主目录下的.vimrc文件中。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>高级技巧</p>
<ul>
<li><p>比较多个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# vim -d foo.txt bar.txt</span><br></pre></td></tr></table></figure>
<p><img src="vim-diff.png" alt=""></p>
</li>
<li><p>打开多个文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# vim foo.txt bar.txt hello.txt</span><br></pre></td></tr></table></figure>

<p>启动vim后只有一个窗口显示的是foo.txt，可以在末行模式中输入<code>ls</code>查看到打开的三个文件，也可以在末行模式中输入<code>b &lt;num&gt;</code>来显示另一个文件，例如可以用<code>:b 2</code>将bar.txt显示出来，可以用<code>:b 3</code>将hello.txt显示出来。</p>
</li>
<li><p>拆分和切换窗口。</p>
<p>可以在末行模式中输入<code>sp</code>或<code>vs</code>来实现对窗口的水平或垂直拆分，这样我们就可以同时打开多个编辑窗口，通过按两次<code>Ctrl+w</code>就可以实现编辑窗口的切换，在一个窗口中执行退出操作只会关闭对应的窗口，其他的窗口继续保留。</p>
<p><img src="vim-multi-window.png" alt=""></p>
</li>
<li><p>映射快捷键：在vim下可以将一些常用操作映射为快捷键来提升工作效率。</p>
<ul>
<li><p>例子1：在命令模式下输入<code>F4</code>执行从第一行开始删除10000行代码的操作。</p>
<p><code>:map &lt;F4&gt; gg10000dd</code>。</p>
<p>例子2：在编辑模式下输入<code>__main</code>直接补全为<code>if __name__ == &#39;__main__&#39;:</code>。</p>
<p><code>:inoremap __main if __name__ == &#39;__main__&#39;:</code></p>
</li>
</ul>
<blockquote>
<p>说明：上面例子2的<code>inoremap</code>中的<code>i</code>表示映射的键在编辑模式使用， <code>nore</code>表示不要递归，这一点非常重要，否则如果键对应的内容中又出现键本身，就会引发递归（相当于进入了死循环）。如果希望映射的快捷键每次启动vim时都能生效，需要将映射写到用户主目录下的.vimrc文件中。</p>
</blockquote>
</li>
<li><p>录制宏。</p>
<ul>
<li><p>在命令模式下输入<code>qa</code>开始录制宏（其中<code>a</code>是寄存器的名字，也可以是其他英文字母或0-9的数字）。</p>
</li>
<li><p>执行你的操作（光标操作、编辑操作等），这些操作都会被录制下来。</p>
</li>
<li><p>如果录制的操作已经完成了，按<code>q</code>结束录制。</p>
</li>
<li><p>通过<code>@a</code>（<code>a</code>是刚才使用的寄存器的名字）播放宏，如果要多次执行宏可以在前面加数字，例如<code>100@a</code>表示将宏播放100次。</p>
</li>
<li><p>可以试一试下面的例子来体验录制宏的操作，该例子来源于<a href="https://harttle.land/tags.html#Vim" target="_blank" rel="noopener">Harttle Land网站</a>，该网站上提供了很多关于vim的使用技巧，有兴趣的可以去了解一下。</p>
<p><img src="vim-macro.png" alt=""></p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="软件安装和配置"><a href="#软件安装和配置" class="headerlink" title="软件安装和配置"></a>软件安装和配置</h3><h4 id="使用包管理工具"><a href="#使用包管理工具" class="headerlink" title="使用包管理工具"></a>使用包管理工具</h4><ol>
<li><strong>yum</strong> - Yellowdog Updater Modified。<ul>
<li><code>yum search</code>：搜索软件包，例如<code>yum search nginx</code>。</li>
<li><code>yum list installed</code>：列出已经安装的软件包，例如<code>yum list installed | grep zlib</code>。</li>
<li><code>yum install</code>：安装软件包，例如<code>yum install nginx</code>。</li>
<li><code>yum remove</code>：删除软件包，例如<code>yum remove nginx</code>。</li>
<li><code>yum update</code>：更新软件包，例如<code>yum update</code>可以更新所有软件包，而<code>yum update tar</code>只会更新tar。</li>
<li><code>yum check-update</code>：检查有哪些可以更新的软件包。</li>
<li><code>yum info</code>：显示软件包的相关信息，例如<code>yum info nginx</code>。</li>
</ul>
</li>
<li><strong>rpm</strong> - Redhat Package Manager。<ul>
<li>安装软件包：<code>rpm -ivh &lt;packagename&gt;.rpm</code>。</li>
<li>移除软件包：<code>rpm -e &lt;packagename&gt;</code>。</li>
<li>查询软件包：<code>rpm -qa</code>，例如可以用<code>rpm -qa | grep mysql</code>来检查是否安装了MySQL相关的软件包。</li>
</ul>
</li>
</ol>
<p>下面以Nginx为例，演示如何使用yum安装软件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# yum -y install nginx</span><br><span class="line">...</span><br><span class="line">Installed:</span><br><span class="line">  nginx.x86_64 1:1.12.2-2.el7</span><br><span class="line">Dependency Installed:</span><br><span class="line">  nginx-all-modules.noarch 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-http-geoip.x86_64 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-http-image-filter.x86_64 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-http-perl.x86_64 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-http-xslt-filter.x86_64 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-mail.x86_64 1:1.12.2-2.el7</span><br><span class="line">  nginx-mod-stream.x86_64 1:1.12.2-2.el7</span><br><span class="line">Complete!</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# yum info nginx</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">Installed Packages</span><br><span class="line">Name        : nginx</span><br><span class="line">Arch        : x86_64</span><br><span class="line">Epoch       : 1</span><br><span class="line">Version     : 1.12.2</span><br><span class="line">Release     : 2.el7</span><br><span class="line">Size        : 1.5 M</span><br><span class="line">Repo        : installed</span><br><span class="line">From repo   : epel</span><br><span class="line">Summary     : A high performance web server and reverse proxy server</span><br><span class="line">URL         : http://nginx.org/</span><br><span class="line">License     : BSD</span><br><span class="line">Description : Nginx is a web server and a reverse proxy server for HTTP, SMTP, POP3 and</span><br><span class="line">            : IMAP protocols, with a strong focus on high concurrency, performance and low</span><br><span class="line">            : memory usage.</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# nginx -v</span><br><span class="line">nginx version: nginx/1.12.2</span><br></pre></td></tr></table></figure>

<p>移除Nginx。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# nginx -s stop</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# yum -y remove nginx</span><br></pre></td></tr></table></figure>

<p>下面以MySQL为例，演示如何使用rpm安装软件。要安装MySQL需要先到<a href="https://www.mysql.com/" target="_blank" rel="noopener">MySQL官方网站</a>下载对应的<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">RPM文件</a>，当然要选择和你使用的Linux系统对应的版本。MySQL现在是Oracle公司旗下的产品，在MySQL被收购后，MySQL的作者重新制作了一个MySQL的分支MariaDB，可以通过yum进行安装。如果要安装MySQL需要先通过yum删除<code>mariadb-libs</code>这个可能会跟MySQL底层库冲突的库，然后还需要安装一个名为<code>libaio</code>的依赖库。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z mysql]# ls</span><br><span class="line">mysql-community-client-5.7.22-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-common-5.7.22-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-libs-5.7.22-1.el7.x86_64.rpm</span><br><span class="line">mysql-community-server-5.7.22-1.el7.x86_64.rpm</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z mysql]# yum -y remove mariadb-libs</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z mysql]# yum -y install libaio</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z mysql]# ls | xargs rpm -ivh</span><br><span class="line">warning: mysql-community-client-5.7.22-1.el7.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：由于MySQL和<a href="https://mariadb.org/" target="_blank" rel="noopener">MariaDB</a>的底层依赖库是有冲突的，所以上面我们首先用<code>yum</code>移除了名为mariadb-libs的依赖库并安装了名为libaio的依赖库。由于我们将安装MySQL所需的rpm文件放在一个独立的目录中，所以可以通过<code>ls</code>命令查看到安装文件并用<code>xargs</code>将<code>ls</code>的输出作为参数交给<code>rpm -ivh</code>来进行安装。关于MySQL和MariaDB之间的关系，可以阅读<a href="https://zh.wikipedia.org/wiki/MariaDB" target="_blank" rel="noopener">维基百科</a>上关于MariaDB的介绍。</p>
</blockquote>
<p>移除安装的MySQL。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# rpm -qa | grep mysql | xargs rpm -e</span><br></pre></td></tr></table></figure>

<h4 id="下载解压配置环境变量"><a href="#下载解压配置环境变量" class="headerlink" title="下载解压配置环境变量"></a>下载解压配置环境变量</h4><p>下面以安装MongoDB为例，演示这类软件应该如何安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz</span><br><span class="line">--2018-06-21 18:32:53--  https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-3.6.5.tgz</span><br><span class="line">Resolving fastdl.mongodb.org (fastdl.mongodb.org)... 52.85.83.16, 52.85.83.228, 52.85.83.186, ...</span><br><span class="line">Connecting to fastdl.mongodb.org (fastdl.mongodb.org)|52.85.83.16|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 100564462 (96M) [application/x-gzip]</span><br><span class="line">Saving to: ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’</span><br><span class="line"><span class="meta">100%</span><span class="bash">[==================================================&gt;] 100,564,462  630KB/s   <span class="keyword">in</span> 2m 9s</span></span><br><span class="line">2018-06-21 18:35:04 (760 KB/s) - ‘mongodb-linux-x86_64-rhel70-3.6.5.tgz’ saved [100564462/100564462]</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip mongodb-linux-x86_64-rhel70-3.6.5.tgz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf mongodb-linux-x86_64-rhel70-3.6.5.tar</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/README</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/THIRD-PARTY-NOTICES</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/MPL-2</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/GNU-AGPL-3.0</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongodump</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongorestore</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoexport</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoimport</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongostat</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongotop</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/bsondump</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongofiles</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoreplay</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongoperf</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongod</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongos</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/mongo</span><br><span class="line">mongodb-linux-x86_64-rhel70-3.6.5/bin/install_compass</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# vim .bash_profile</span><br><span class="line">...</span><br><span class="line">PATH=$PATH:$HOME/bin:$HOME/mongodb-linux-x86_64-rhel70-3.6.5/bin</span><br><span class="line">export PATH</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# source .bash_profile</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mongod --version</span><br><span class="line">db version v3.6.5</span><br><span class="line">git version: a20ecd3e3a174162052ff99913bc2ca9a839d618</span><br><span class="line">OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class="line">allocator: tcmalloc</span><br><span class="line">modules: none</span><br><span class="line">build environment:</span><br><span class="line">    distmod: rhel70</span><br><span class="line">    distarch: x86_64</span><br><span class="line">    target_arch: x86_64</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mongo --version</span><br><span class="line">MongoDB shell version v3.6.5</span><br><span class="line">git version: a20ecd3e3a174162052ff99913bc2ca9a839d618</span><br><span class="line">OpenSSL version: OpenSSL 1.0.1e-fips 11 Feb 2013</span><br><span class="line">allocator: tcmalloc</span><br><span class="line">modules: none</span><br><span class="line">build environment:</span><br><span class="line">    distmod: rhel70</span><br><span class="line">    distarch: x86_64</span><br><span class="line">    target_arch: x86_64</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：当然也可以通过yum来安装MongoDB，具体可以参照<a href="https://docs.mongodb.com/master/administration/install-on-linux/" target="_blank" rel="noopener">官方网站</a>上给出的说明。</p>
</blockquote>
<h4 id="源代码构建安装"><a href="#源代码构建安装" class="headerlink" title="源代码构建安装"></a>源代码构建安装</h4><ol>
<li><p>安装Python 3.6。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# yum install gcc</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget https://www.python.org/ftp/python/3.6.5/Python-3.6.5.tgz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip Python-3.6.5.tgz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf Python-3.6.5.tar</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cd Python-3.6.5</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ./configure --prefix=/usr/local/python36 --enable-optimizations</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# yum -y install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db4-devel libpcap-devel xz-devel</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# make &amp;&amp; make install</span><br><span class="line">... 配置环境变量 ...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ln -s /usr/local/python36/bin/python3.6 /usr/bin/python3</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# python3 --version</span><br><span class="line">Python 3.6.5</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# python3 -m pip install -U pip</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# pip3 --version</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Redis-3.2.12。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# wget http://download.redis.io/releases/redis-3.2.12.tar.gz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# gunzip redis-3.2.12.tar.gz</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# tar -xvf redis-3.2.12.tar</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cd redis-3.2.12</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# make &amp;&amp; make install</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# redis-server --version</span><br><span class="line">Redis server v=3.2.12 sha=00000000:0 malloc=jemalloc-4.0.3 bits=64 build=5bc5cd3c03d6ceb6</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# redis-cli --version</span><br><span class="line">redis-cli 3.2.12</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><ol>
<li><p>启动服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl start firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>终止服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl stop firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl restart firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看服务。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl status firewalld</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置是否开机自启。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl enable firewalld</span><br><span class="line">Created symlink from /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service to /usr/lib/systemd/system/firewalld.service.</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/firewalld.service to /usr/lib/systemd/system/firewalld.service.</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# systemctl disable firewalld</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/firewalld.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service.</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><ol>
<li><p><strong>crontab</strong>命令。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# crontab -e</span><br><span class="line">* * * * * echo "hello, world!" &gt;&gt; /root/hello.txt</span><br><span class="line">59 23 * * * rm -f /root/*.log</span><br></pre></td></tr></table></figure>
<blockquote>
<p>说明：输入<code>crontab -e</code>命令会打开vim来编辑Cron表达式并指定触发的任务，上面我们定制了两个计划任务，一个是每分钟向/root目录下的hello.txt中追加输出<code>hello, world!</code>；另一个是每天23时59分执行删除/root目录下以log为后缀名的文件。如果不知道Cron表达式如何书写，可以参照/etc/crontab文件中的提示（下面会讲到）或者用谷歌或百度搜索一下，也可以使用Cron表达式在线生成器来生成Cron表达式。</p>
</blockquote>
</li>
<li><p>crontab相关文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# cd /etc</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z etc]# ls -l | grep cron</span><br><span class="line">-rw-------.  1 root root      541 Aug  3  2017 anacrontab</span><br><span class="line">drwxr-xr-x.  2 root root     4096 Mar 27 11:56 cron.d</span><br><span class="line">drwxr-xr-x.  2 root root     4096 Mar 27 11:51 cron.daily</span><br><span class="line">-rw-------.  1 root root        0 Aug  3  2017 cron.deny</span><br><span class="line">drwxr-xr-x.  2 root root     4096 Mar 27 11:50 cron.hourly</span><br><span class="line">drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.monthly</span><br><span class="line">-rw-r--r--   1 root root      493 Jun 23 15:09 crontab</span><br><span class="line">drwxr-xr-x.  2 root root     4096 Jun 10  2014 cron.weekly</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z etc]# vim crontab</span><br><span class="line">  1 SHELL=/bin/bash</span><br><span class="line">  2 PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">  3 MAILTO=root</span><br><span class="line">  4</span><br><span class="line">  5 # For details see man 4 crontabs</span><br><span class="line">  6</span><br><span class="line">  7 # Example of job definition:</span><br><span class="line">  8 # .---------------- minute (0 - 59)</span><br><span class="line">  9 # |  .------------- hour (0 - 23)</span><br><span class="line"> 10 # |  |  .---------- day of month (1 - 31)</span><br><span class="line"> 11 # |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class="line"> 12 # |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class="line"> 13 # |  |  |  |  |</span><br><span class="line"> 14 # *  *  *  *  * user-name  command to be executed</span><br></pre></td></tr></table></figure>

<p>通过修改<code>/etc</code>目录下的crontab文件也能够定制计划任务。</p>
</li>
</ol>
<h3 id="网络访问和管理"><a href="#网络访问和管理" class="headerlink" title="网络访问和管理"></a>网络访问和管理</h3><ol>
<li><p>安全远程连接 - <strong>ssh</strong>。</p>
</li>
<li><p>通过网络获取资源 - <strong>wget</strong>。</p>
<ul>
<li>-b 后台下载模式</li>
<li>-O 下载到指定的目录</li>
<li>-r 递归下载</li>
</ul>
</li>
<li><p>显示/操作网络配置（旧） - <strong>ifconfig</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ifconfig eth0</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.18.61.250  netmask 255.255.240.0  broadcast 172.18.63.255</span><br><span class="line">        ether 00:16:3e:02:b6:46  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 1067841  bytes 1296732947 (1.2 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 409912  bytes 43569163 (41.5 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示/操作网络配置（新） - <strong>ip</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ip address</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000</span><br><span class="line">    link/ether 00:16:3e:02:b6:46 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.18.61.250/20 brd 172.18.63.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
</li>
<li><p>网络可达性检查 - <strong>ping</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ping www.baidu.com -c 3</span><br><span class="line">PING www.a.shifen.com (220.181.111.188) 56(84) bytes of data.</span><br><span class="line">64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=1 ttl=51 time=36.3 ms</span><br><span class="line">64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=2 ttl=51 time=36.4 ms</span><br><span class="line">64 bytes from 220.181.111.188 (220.181.111.188): icmp_seq=3 ttl=51 time=36.4 ms</span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2002ms</span><br><span class="line">rtt min/avg/max/mdev = 36.392/36.406/36.427/0.156 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看网络服务和端口 - <strong>netstat</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# netstat -nap | grep nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全文件拷贝 - <strong>scp</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# scp root@1.2.3.4:/root/guido.jpg hellokitty@4.3.2.1:/home/hellokitty/pic.jpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>安全文件传输 - <strong>sftp</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# sftp root@120.77.222.217</span><br><span class="line">root@120.77.222.217's password:</span><br><span class="line">Connected to 120.77.222.217.</span><br><span class="line"><span class="meta">sftp&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>help</code>：显示帮助信息。</p>
</li>
<li><p><code>ls</code>/<code>lls</code>：显示远端/本地目录列表。</p>
</li>
<li><p><code>cd</code>/<code>lcd</code>：切换远端/本地路径。</p>
</li>
<li><p><code>mkdir</code>/<code>lmkdir</code>：创建远端/本地目录。</p>
</li>
<li><p><code>pwd</code>/<code>lpwd</code>：显示远端/本地当前工作目录。</p>
</li>
<li><p><code>get</code>：下载文件。</p>
</li>
<li><p><code>put</code>：上传文件。</p>
</li>
<li><p><code>rm</code>：删除远端文件。</p>
</li>
<li><p><code>bye</code>/<code>exit</code>/<code>quit</code>：退出sftp。</p>
</li>
</ul>
</li>
</ol>
<h3 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h3><ol>
<li><p><strong>ps</strong> - 查询进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 Jun23 ?        00:00:05 /usr/lib/systemd/systemd --switched-root --system --deserialize 21</span><br><span class="line">root         2     0  0 Jun23 ?        00:00:00 [kthreadd]</span><br><span class="line">...</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ps -ef | grep mysqld</span><br><span class="line">root      4943  4581  0 22:45 pts/0    00:00:00 grep --color=auto mysqld</span><br><span class="line">mysql    25257     1  0 Jun25 ?        00:00:39 /usr/sbin/mysqld --daemonize --pid-file=/var/run/mysqld/mysqld.pid</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>kill</strong> - 终止进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# kill 1234</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# kill -9 1234</span><br></pre></td></tr></table></figure>

<p>例子：用一条命令强制终止正在运行的Redis进程。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis | grep -v grep | awk '&#123;print $2&#125;' | xargs kill</span><br></pre></td></tr></table></figure>
</li>
<li><p>将进程置于后台运行。</p>
<ul>
<li><code>Ctrl+Z</code></li>
<li><code>&amp;</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# mongod &amp;</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# redis-server</span><br><span class="line">...</span><br><span class="line">^Z</span><br><span class="line">[4]+  Stopped                 redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>jobs</strong> - 查询后台进程。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# jobs</span><br><span class="line">[2]   Running                 mongod &amp;</span><br><span class="line">[3]-  Stopped                 cat</span><br><span class="line">[4]+  Stopped                 redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>bg</strong> - 让进程在后台继续运行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# bg %4</span><br><span class="line">[4]+ redis-server &amp;</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# jobs</span><br><span class="line">[2]   Running                 mongod &amp;</span><br><span class="line">[3]+  Stopped                 cat</span><br><span class="line">[4]-  Running                 redis-server &amp;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>fg</strong> - 将后台进程置于前台。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# fg %4</span><br><span class="line">redis-server</span><br><span class="line">^C5554:signal-handler (1530025281) Received SIGINT scheduling shutdown...</span><br><span class="line">5554:M 26 Jun 23:01:21.413 # User requested shutdown...</span><br><span class="line">5554:M 26 Jun 23:01:21.413 * Saving the final RDB snapshot before exiting.</span><br><span class="line">5554:M 26 Jun 23:01:21.415 * DB saved on disk</span><br><span class="line">5554:M 26 Jun 23:01:21.415 # Redis is now ready to exit, bye bye...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：置于前台的进程可以使用<code>Ctrl+C</code>来终止它。</p>
</blockquote>
</li>
<li><p><strong>top</strong> - 进程监控。</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# top</span><br><span class="line">top - 23:04:23 up 3 days, 14:10,  1 user,  load average: 0.00, 0.01, 0.05</span><br><span class="line">Tasks:  65 total,   1 running,  64 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta">%</span><span class="bash">Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem :  1016168 total,   191060 free,   324700 used,   500408 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used.   530944 avail Mem</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="系统性能"><a href="#系统性能" class="headerlink" title="系统性能"></a>系统性能</h3><ol>
<li><p>查看系统活动信息 - <strong>sar</strong>。</p>
</li>
<li><p>查看内存使用情况 - <strong>free</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        1016168      323924      190452         356      501792      531800</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 4581 pts/0    00:00:00 bash</span><br><span class="line"> 5664 pts/0    00:00:00 ps</span><br><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# pmap 4581</span><br><span class="line">4581:   -bash</span><br><span class="line">0000000000400000    884K r-x-- bash</span><br><span class="line">00000000006dc000      4K r---- bash</span><br><span class="line">00000000006dd000     36K rw--- bash</span><br><span class="line">00000000006e6000     24K rw---   [ anon ]</span><br><span class="line">0000000001de0000    400K rw---   [ anon ]</span><br><span class="line">00007f82fe805000     48K r-x-- libnss_files-2.17.so</span><br><span class="line">00007f82fe811000   2044K ----- libnss_files-2.17.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>报告设备CPU和I/O统计信息 - <strong>iostat</strong>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@iZwz97tbgo9lkabnat2lo8Z ~]# iostat</span><br><span class="line">Linux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06/26/2018      _x86_64_       (1 CPU)</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.79    0.00    0.20    0.04    0.00   98.97</span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">vda               0.85         6.78        21.32    2106565    6623024</span><br><span class="line">vdb               0.00         0.01         0.00       2088          0</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="系统诊断"><a href="#系统诊断" class="headerlink" title="系统诊断"></a>系统诊断</h3><ol>
<li><p>系统启动异常诊断 - <strong>dmesg</strong>。</p>
</li>
<li><p>查看系统活动信息 - <strong>sar</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# sar -u -r 5 10</span><br><span class="line">Linux 3.10.0-957.10.1.el7.x86_64 (izwz97tbgo9lkabnat2lo8z)      06&#x2F;02&#x2F;2019      _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">06:48:30 PM     CPU     %user     %nice   %system   %iowait    %steal     %idle</span><br><span class="line">06:48:35 PM     all      0.10      0.00      0.10      0.00      0.00     99.80</span><br><span class="line"></span><br><span class="line">06:48:30 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty</span><br><span class="line">06:48:35 PM   1772012   2108392     54.33    102816   1634528    784940     20.23    793328   1164704         0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-A</code> - 显示所有设备（CPU、内存、磁盘）的运行状况。</li>
<li><code>-u</code> - 显示所有CPU的负载情况。</li>
<li><code>-d</code> - 显示所有磁盘的使用情况。</li>
<li><code>-r</code> - 显示内存的使用情况。</li>
<li><code>-n</code> - 显示网络运行状态。</li>
</ul>
</li>
<li><p>查看内存使用情况 - <strong>free</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# free</span><br><span class="line">              total        used        free      shared  buff&#x2F;cache   available</span><br><span class="line">Mem:        1016168      323924      190452         356      501792      531800</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure>
</li>
<li><p>虚拟内存统计 - <strong>vmstat</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# vmstat</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 2  0      0 204020  79036 667532    0    0     5    18  101   58  1  0 99  0  0</span><br></pre></td></tr></table></figure>
</li>
<li><p>CPU信息统计 - <strong>mpstat</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# mpstat</span><br><span class="line">Linux 3.10.0-957.5.1.el7.x86_64 (iZ8vba0s66jjlfmo601w4xZ)       05&#x2F;30&#x2F;2019      _x86_64_        (1 CPU)</span><br><span class="line"></span><br><span class="line">01:51:54 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle</span><br><span class="line">01:51:54 AM  all    0.71    0.00    0.17    0.04    0.00    0.00    0.00    0.00    0.00   99.07</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看进程使用内存状况 - <strong>pmap</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line"> 4581 pts&#x2F;0    00:00:00 bash</span><br><span class="line"> 5664 pts&#x2F;0    00:00:00 ps</span><br><span class="line">[root ~]# pmap 4581</span><br><span class="line">4581:   -bash</span><br><span class="line">0000000000400000    884K r-x-- bash</span><br><span class="line">00000000006dc000      4K r---- bash</span><br><span class="line">00000000006dd000     36K rw--- bash</span><br><span class="line">00000000006e6000     24K rw---   [ anon ]</span><br><span class="line">0000000001de0000    400K rw---   [ anon ]</span><br><span class="line">00007f82fe805000     48K r-x-- libnss_files-2.17.so</span><br><span class="line">00007f82fe811000   2044K ----- libnss_files-2.17.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p>报告设备CPU和I/O统计信息 - <strong>iostat</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# iostat</span><br><span class="line">Linux 3.10.0-693.11.1.el7.x86_64 (iZwz97tbgo9lkabnat2lo8Z)      06&#x2F;26&#x2F;2018      _x86_64_       (1 CPU)</span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           0.79    0.00    0.20    0.04    0.00   98.97</span><br><span class="line">Device:            tps    kB_read&#x2F;s    kB_wrtn&#x2F;s    kB_read    kB_wrtn</span><br><span class="line">vda               0.85         6.78        21.32    2106565    6623024</span><br><span class="line">vdb               0.00         0.01         0.00       2088          0</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示所有PCI设备 - <strong>lspci</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# lspci</span><br><span class="line">00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)</span><br><span class="line">00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma&#x2F;Triton II]</span><br><span class="line">00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma&#x2F;Triton II]</span><br><span class="line">00:01.2 USB controller: Intel Corporation 82371SB PIIX3 USB [Natoma&#x2F;Triton II] (rev 01)</span><br><span class="line">00:01.3 Bridge: Intel Corporation 82371AB&#x2F;EB&#x2F;MB PIIX4 ACPI (rev 03)</span><br><span class="line">00:02.0 VGA compatible controller: Cirrus Logic GD 5446</span><br><span class="line">00:03.0 Ethernet controller: Red Hat, Inc. Virtio network device</span><br><span class="line">00:04.0 Communication controller: Red Hat, Inc. Virtio console</span><br><span class="line">00:05.0 SCSI storage controller: Red Hat, Inc. Virtio block device</span><br><span class="line">00:06.0 SCSI storage controller: Red Hat, Inc. Virtio block device</span><br><span class="line">00:07.0 Unclassified device [00ff]: Red Hat, Inc. Virtio memory balloon</span><br></pre></td></tr></table></figure>
</li>
<li><p>显示进程间通信设施的状态 - <strong>ipcs</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root ~]# ipcs</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages    </span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h3><p>之前我们提到过，Shell是一个连接用户和操作系统的应用程序，它提供了人机交互的界面（接口），用户通过这个界面访问操作系统内核的服务。Shell脚本是一种为Shell编写的脚本程序，我们可以通过Shell脚本来进行系统管理，同时也可以通过它进行文件操作。总之，编写Shell脚本对于使用Linux系统的人来说，应该是一项标配技能。</p>
<p>互联网上有大量关于Shell脚本的相关知识，我不打算再此对Shell脚本做一个全面系统的讲解，我们通过下面的代码来感性的认识下Shell脚本就行了。</p>
<p>例子1：输入两个整数m和n，计算从m到n的整数求和的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">printf &#39;m &#x3D; &#39;</span><br><span class="line">read m</span><br><span class="line">printf &#39;n &#x3D; &#39;</span><br><span class="line">read n</span><br><span class="line">a&#x3D;$m</span><br><span class="line">sum&#x3D;0</span><br><span class="line">while [ $a -le $n ]</span><br><span class="line">do</span><br><span class="line">    sum&#x3D;$[ sum + a ]</span><br><span class="line">    a&#x3D;$[ a + 1 ]</span><br><span class="line">done</span><br><span class="line">echo &#39;结果: &#39;$sum</span><br></pre></td></tr></table></figure>

<p>例子2：自动创建文件夹和指定数量的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">printf &#39;输入文件名: &#39;</span><br><span class="line">read file</span><br><span class="line">printf &#39;输入文件数量(&lt;1000): &#39;</span><br><span class="line">read num</span><br><span class="line">if [ $num -ge 1000 ]</span><br><span class="line">then</span><br><span class="line">    echo &#39;文件数量不能超过1000&#39;</span><br><span class="line">else</span><br><span class="line">    if [ -e $dir -a -d $dir ]</span><br><span class="line">    then</span><br><span class="line">        rm -rf $dir</span><br><span class="line">    else</span><br><span class="line">        if [ -e $dir -a -f $dir ]</span><br><span class="line">        then</span><br><span class="line">            rm -f $dir</span><br><span class="line">        fi</span><br><span class="line">    fi</span><br><span class="line">    mkdir -p $dir</span><br><span class="line">    index&#x3D;1</span><br><span class="line">    while [ $index -le $num ]</span><br><span class="line">    do</span><br><span class="line">        if [ $index -lt 10 ]</span><br><span class="line">        then</span><br><span class="line">            pre&#x3D;&#39;00&#39;</span><br><span class="line">        elif [ $index -lt 100 ]</span><br><span class="line">        then</span><br><span class="line">            pre&#x3D;&#39;0&#39;</span><br><span class="line">        else</span><br><span class="line">            pre&#x3D;&#39;&#39;</span><br><span class="line">        fi</span><br><span class="line">        touch $dir&#39;&#x2F;&#39;$file&#39;_&#39;$pre$index</span><br><span class="line">        index&#x3D;$[ index + 1 ]</span><br><span class="line">    done</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p>例子3：自动安装指定版本的Redis。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;bash</span><br><span class="line">install_redis() &#123;</span><br><span class="line">    if ! which redis-server &gt; &#x2F;dev&#x2F;null</span><br><span class="line">    then</span><br><span class="line">        cd &#x2F;root</span><br><span class="line">        wget $1$2&#39;.tar.gz&#39; &gt;&gt; install.log</span><br><span class="line">        gunzip &#x2F;root&#x2F;$2&#39;.tar.gz&#39;</span><br><span class="line">        tar -xf &#x2F;root&#x2F;$2&#39;.tar&#39;</span><br><span class="line">        cd &#x2F;root&#x2F;$2</span><br><span class="line">        make &gt;&gt; install.log</span><br><span class="line">        make install &gt;&gt; install.log</span><br><span class="line">        echo &#39;安装完成&#39;</span><br><span class="line">    else</span><br><span class="line">        echo &#39;已经安装过Redis&#39;</span><br><span class="line">    fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">install_redis &#39;http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;&#39; $1</span><br></pre></td></tr></table></figure>

<h3 id="相关资源"><a href="#相关资源" class="headerlink" title="相关资源"></a>相关资源</h3><ol>
<li><p>Linux命令行常用快捷键</p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>tab</td>
<td>自动补全命令或路径</td>
</tr>
<tr>
<td>Ctrl+a</td>
<td>将光标移动到命令行行首</td>
</tr>
<tr>
<td>Ctrl+e</td>
<td>将光标移动到命令行行尾</td>
</tr>
<tr>
<td>Ctrl+f</td>
<td>将光标向右移动一个字符</td>
</tr>
<tr>
<td>Ctrl+b</td>
<td>将光标向左移动一个字符</td>
</tr>
<tr>
<td>Ctrl+k</td>
<td>剪切从光标到行尾的字符</td>
</tr>
<tr>
<td>Ctrl+u</td>
<td>剪切从光标到行首的字符</td>
</tr>
<tr>
<td>Ctrl+w</td>
<td>剪切光标前面的一个单词</td>
</tr>
<tr>
<td>Ctrl+y</td>
<td>复制剪切命名剪切的内容</td>
</tr>
<tr>
<td>Ctrl+c</td>
<td>中断正在执行的任务</td>
</tr>
<tr>
<td>Ctrl+h</td>
<td>删除光标前面的一个字符</td>
</tr>
<tr>
<td>Ctrl+d</td>
<td>退出当前命令行</td>
</tr>
<tr>
<td>Ctrl+r</td>
<td>搜索历史命令</td>
</tr>
<tr>
<td>Ctrl+g</td>
<td>退出历史命令搜索</td>
</tr>
<tr>
<td>Ctrl+l</td>
<td>清除屏幕上所有内容在屏幕的最上方开启一个新行</td>
</tr>
<tr>
<td>Ctrl+s</td>
<td>锁定终端使之暂时无法输入内容</td>
</tr>
<tr>
<td>Ctrl+q</td>
<td>退出终端锁定</td>
</tr>
<tr>
<td>Ctrl+z</td>
<td>将正在终端执行的任务停下来放到后台</td>
</tr>
<tr>
<td>!!</td>
<td>执行上一条命令</td>
</tr>
<tr>
<td>!数字</td>
<td>执行数字对应的历史命令</td>
</tr>
<tr>
<td>!字母</td>
<td>执行最近的以字母打头的命令</td>
</tr>
<tr>
<td>!$ / Esc+.</td>
<td>获得上一条命令最后一个参数</td>
</tr>
<tr>
<td>Esc+b</td>
<td>移动到当前单词的开头</td>
</tr>
<tr>
<td>Esc+f</td>
<td>移动到当前单词的结尾</td>
</tr>
</tbody></table>
</li>
<li><p>man查阅命令手册的内容说明</p>
<table>
<thead>
<tr>
<th>手册中的标题</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>NAME</td>
<td>命令的说明和介绍</td>
</tr>
<tr>
<td>SYNOPSIS</td>
<td>使用该命令的基本语法</td>
</tr>
<tr>
<td>DESCRIPTION</td>
<td>使用该命令的详细描述，各个参数的作用，有时候这些信息会出现在OPTIONS中</td>
</tr>
<tr>
<td>OPTIONS</td>
<td>命令相关参数选项的说明</td>
</tr>
<tr>
<td>EXAMPLES</td>
<td>使用该命令的参考例子</td>
</tr>
<tr>
<td>EXIT STATUS</td>
<td>命令结束的退出状态码，通常0表示成功执行</td>
</tr>
<tr>
<td>SEE ALSO</td>
<td>和命令相关的其他命令或信息</td>
</tr>
<tr>
<td>BUGS</td>
<td>和命令相关的缺陷的描述</td>
</tr>
<tr>
<td>AUTHOR</td>
<td>该命令的作者介绍</td>
</tr>
</tbody></table>
</li>
</ol>
]]></content>
      <categories>
        <category>Tutorials</category>
        <category>Linux</category>
      </categories>
  </entry>
</search>
